# 一、概述

[Babel >>](<https://www.babeljs.cn/>)  是一个 JavaScript 编译器（转换器），主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：

- 语法转换
- 通过 `Polyfill` 方式在目标环境中添加缺失的特性 （通过引入第三方 `polyfill` 模块，例如 [core-js](https://github.com/zloirock/core-js)）
- 源码转换 (`codemods`)

借助Babel，开发者可以提前用上新的 JavaScript 特性，这对生产力的提升大有帮助。实现Babel代码转换功能的核心，就是Babel插件（`plugin`）。

转换过程（初探）：`原始代码` — `[Babel Plugin]`   — `转换后的代码`

> 注意：Babel 并不是要把 ES6 转成 ES5，而是把比较少支持的特性转换成更多支持的写法，这样一来，写代码的人可以用到最新最先进的写法，将来整个用户客户端升级了，也无需修改代码，修改 babel 配置即可，所以 babel 转换哪些代码是可以配置的，一般用 `@babel/preset-env`，所以你要先看自己的配置，如果有必要，也可以手动添加一些插件。

# 二、使用指南

## 1、起步

创建一个基本的项目文件结构，并新建必要文件，如下所示：

```ini
babel-demo
.
├── src
│   └── app.js  
└── package.json
```

> 注意：` package.json` 文件通过 `npm init -y` 指令自动生成。

## 2、安装依赖

```shell
$ npm init -y
$ npm install --save-dev @babel/core @babel/cli @babel/preset-env
```

## 3、配置文件

在根目录中创建 `babel.config.json` 配置文件，并设置转换规则，并将一下内容复制到此文件中：

```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": ["last 2 versions", "safari >= 7"]
        },
        "useBuiltIns": "usage",
        "corejs": "3.6.5"
      }
    ]
  ]
}
```

> 上述浏览器列表仅用于示例。请根据你所需要支持的浏览器进行调整。参见 [此处](https://www.babeljs.cn/docs/babel-preset-env) 以了解 `@babel/preset-env` 可接受哪些参数。

## 4、基本使用

通过上面的准备工作，我们现在就可以使用 Babel 编译 ES6 了。在 `/src/app.js` 文件中写一个es6的箭头函数

```javascript
(function () {
  const hello = (name) => {
    console.log(`Hello, ${name}!`);
  };
  hello('Babel');
})();
```

现在使用Babel命令进行编译

```shell
# -- 编译文件
$ ./node_modules/.bin/babel src/app.js --out-file lib/app.js -w -s
# -- 编译目录
$ ./node_modules/.bin/babel src --out-dir lib -w -s
```

解读：

- `-o`：将某个js文件编译成指定js文件

- `-d`：将某个目录下的js文件编译至指定目录

- `-w`：实时监听文件/自动编译

- `-s`：生成资源映射文件便于调试，它可以帮助你在浏览器开发者工具（目前只有google chrome浏览器支持该功能）的“Source”选项卡中找到编译前的源文件，方便开发者进行调试。

  但首先得确保你开发者工具的设置里的这一项是处于勾选状态：

  右键检查 -> 工具栏中选择更多（右上角三个竖着的小圆点） -> Setting -> Sources -> Enable JavaScript source maps.

经过编译后生成的 `index.js` 是这样的：

```javascript
(function () {
  var hello = function hello(name) {
    console.log("Hello, ".concat(name, "!"));
  };

  hello('Babel');
})();
```

## 5、简化使用

在 `package.json`  文件的 `scripts` 属性下，设置如下代码：

```json
"scripts": {
  "dev": "./node_modules/.bin/babel src --out-dir lib -w -s"
},
```

> 提示：`dev` 这个属性名是自定义的，其属性值则是要执行的指令。

内容配置完成之后，切换到命令行窗口输入：

 ```shell
$ npm run dev
 ```

这样即可执行指令进行编译。

# 三、运行阶段

Babel转码的过程分三个阶段：`解析(parse)`、`转换(transform)`、`生成(generate)`。

其中，解析、生成阶段由Babel核心完成，而转换阶段，则由Babel插件完成。

[AST explorer >>](https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F)

## 1、解析 

[@babel/parser  >>](https://www.babeljs.cn/docs/babel-parser)

```
babelParser.parse(code, [options])：AST
```

- `code`：源代码
- `options.plugins`：包含要启用的插件的数组
- `options.sourceType`：代码应该被解析的模式，默认为 `script`，`unambiguous` 会使 `@babel/parser` 尝试根据 ES6 导入或导出语句的存在进行猜测。 带有 ES6 导入和导出的文件被视为`module`，否则被视为 `script`。

Babel 读入源代码，经过词法分析、语法分析后，生成 [抽象语法树（AST）](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAbstract_syntax_tree)。

## 2、转换

经过前一阶段的代码分析，Babel得到了AST。在原始AST的基础上，Babel通过插件，对其进行修改，比如新增、删除、修改后，得到新的AST。

```javascript
transform(AST, BabelPlugins) => newAST
```

## 3、生成

使用插件 `@babel/generator` 将转换好的 AST 重新生成目标代码。

```javascript
const output = generate(
  ast,
  {
    /* options */
  },
  code
);
```

# 四、插件

## 1、基本结构

典型的 Babel 插件结构，如下代码所示：

```javascript
export default function ({ types: babelTypes }) {
  return {
    visitor: {
      Identifier(path, state) {},
      ASTNodeTypeHere(path, state) {},
    },
  };
}
```

需要关注的内容如下：

- `babelType`：类似lodash那样的工具集，主要用来操作AST节点，比如创建、校验、转变等。举例：判断某个节点是不是标识符（`identifier`）。

- `path`：AST中有很多节点，每个节点可能有不同的属性，并且节点之间可能存在关联。

  `path` 是个对象，它代表了两个节点之间的关联。你可以在path上访问到节点的属性，也可以通过 `path` 来访问到关联的节点（比如父节点、兄弟节点等）

- `state`：代表了插件的状态，你可以通过 `state` 访问插件的配置项。

- `visitor`：Babel 采取递归的方式访问AST的每个节点，之所以叫做 `visitor`，只是因为有个类似的设计模式叫做 [访问者模式](https://en.wikipedia.org/wiki/Visitor_pattern)，不用在意背后的细节。

- `Identifier`、`ASTNodeTypeHere`：AST的每个节点，都有对应的节点类型，比如标识符（`Identifier`）、函数声明（`FunctionDeclaration`）等，可以在 `visitor` 上声明同名的属性，当Babel遍历到相应类型的节点，属性对应的方法就会被调用，传入的参数就是 `path`、`state`。

## 2、插件实例

本例子中，我们实现一个毫无意义的插件：将所有名称为 `bad` 的标识符，转成 `good`

```javascript
// plugins/transferText.js
module.exports = function ({ types: babelTypes }) {
  return {
    name: 'plugin-example',
    visitor: {
      Identifier(path, state) {
        if (path.node.name === 'bad') {
          path.node.name = 'good';
        }
      },
    },
  };
};
```

在配置文件中添加插件：

```javascript
 "plugins": [["./plugins/transferText.js"]]
```

编写代码：

```javascript
// src/app.js
(function () {
  const bad = true;
})();
```

执行转码命令：

```shell
$ npm run dev
```

查看转码结果：

```javascript
(function () {
  var good = true;
})();
```



