# 面试题集锦

## @Web

### **001：前端性能优化**

前端性能评级工具： [PageSpeed >>](https://developers.google.com/speed/pagespeed/insights/)  / YSlow

```markdown
# CSS:
- 合并、压缩CSS，尽量减少http请求；
- 将css文件防止在页面最上面（head标签对内）；
- 移除不用的CSS;
- 避免使用CSS表达式；
- 选择器优化嵌套，避免层级过深；
- 充分利用CSS继承属性或者抽象提取公共样式，减少代码量；
- 属性值为0时不加单位；
- 属性值小于1的小数时省略小数点前面的0；
- 使用CSS Sprites将多张图片拼接成一张图片，通过CSS background 属性来访问图片内容；

# JavaScript
- 防抖、节流；
- 长列表渲染；
- 图片懒加载（src）
- 避免使用闭包，如果使用闭包时，在函数结尾手动删除不需要的局部变量，尤其在缓存dom节点的情况下；
- DOM操作优化：
  * 批量添加DOM可先 createElement 创建并添加节点，最后一次性加入DOM;
  * 批量绑定事件，使用 事件委托 实现，利用事件冒泡特性；
  * 使用innerHTML 替代 appendChild；
  * 处理样式尽量操作class，而不是直接操作 style 属性，减少重排（Reflow）；
  
# 网络
- 减少HTTP 请求数量；
- 利用浏览器缓存，公共依赖包单独打包/单文件在一起，避免重复请求；
- 减少cookie大小，尽量使用 localStorage 代替；
- CDN托管静态文件；
- 开启Gzip压缩；
```

### 002：浏览器内核

主要分为 `渲染引擎` 和 `JS引擎` 两部分，其中：

- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
- JS引擎：解析和执行`javascript`来实现网页的动态效果。

> 提示：最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

### 003：常见浏览器内核

- Trident：IE
- Gecko：Firefox
- Webkit：Safari
- Blink：Chrome/Opera/Edge

## @HTML

### 001：`src` 和 `href` 的区别？

`src` 和 `href` 都是 **用来引用外部的资源**，它们的区别如下：

- `src`：表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。`src` 会将其指向的资源下载并应⽤到⽂档内，如请求 `js` 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 `js` 脚本会放在页面底部。
- `href`：表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 `a`、`link` 等标签上。 

### 002：对HTML语义化的理解？

语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。

语义化的优点如下：

- 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
- 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

常见的语义化标签：

```html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

### 003：DOCTYPE（⽂档类型） 的作⽤？

`DOCTYPE` 是 HTML5 中一种标准通用标记语言的 **文档类型声明**，它的目的是告诉浏览器（解析器）应该以什么样（`html`或`xhtml`）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 `CSS` 代码甚⾄ `JavaScript` 脚本的解析。它必须声明在 `HTML`⽂ 档的第⼀⾏。

浏览器渲染页面的两种模式（可通过 `document.compatMode` 获取）：

- `CSS1Compat`：**标准模式**（`Strick mode`），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 
- `BackCompat`：**怪异模式(混杂模式)**(`Quick mode)`，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。

### 004：script  标签中 `defer` 和 `async` 的区别？

如果没有 `defer` 或 `async` 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

`defer` 和 `async` 属性都是去 **异步加载** 外部的 `JS` 脚本文件，它们都不会阻塞页面的解析，其区别如下：

- **执行顺序：** 
  - 多个带 `async` 属性的标签，不能保证加载的顺序；
  - 多个带 `defer` 属性的标签，按照加载顺序执行；
- **脚本是否并行执行：**
  - `async` 属性，表示后续文档的加载和执行与 `js` 脚本的加载和执行是并行进行的，即异步执行；
  - `defer` 属性，加载后续文档的过程和`js` 脚本的加载（此时仅加载不执行）是并行进行的（异步），`js`脚本需要等到文档所有元素解析完成之后才执行，`DOMContentLoaded` 事件触发执行之前。

### 005：常⽤的 meta 标签有哪些？

`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些 `name` 作为大家使用的共识，开发者还可以自定义 `name`。

常用的meta标签：

1）`charset`，用来描述HTML文档的编码类型：

```html
<meta charset="UTF-8" >
```

2）`keywords`，页面关键词：

```html
<meta name="keywords" content="关键词" />
```

3）`description`，页面描述：

```html
<meta name="description" content="页面描述内容" />
```

4）`refresh`，页面重定向和刷新：

```html
<meta http-equiv="refresh" content="0;url=" />
```

5）`viewport`，适配移动端，可以控制视口的大小和比例：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, viewport-fit=cover" />
```

6）搜索引擎索引方式：

```html
<meta name="robots" content="index,follow" />
```

### 006：HTML5有哪些更新？

（1）新增语义化标签：`nav`、`header`、`footer`、`aside`、`section`、`article`

（2）音频、视频标签：`audio`、`video`

（3）数据存储：`localStorage`、`sessionStorage`

（4）`canvas`（画布）、`Geolocation`（地理定位）、`websocket`（通信协议） 

（5）`input` 标签新增属性：`placeholder`、`autocomplete`、`autofocus`、`required`

（6）`history API`：`go`、`forward`、`back`、`pushstate`

### 007：渐进增强和优雅降级之间的区别？

- **渐进增强**：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
- **优雅降级**：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

二者的区别：

- 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
- 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。

> **优雅降级** 观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。

> **渐进增强** 观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。

### 008：说一下 HTML5 drag API?

（1）被拖放元素：

- `dragstart`：在开始拖放被拖放元素时触发。

- `darg`：在正在拖放被拖放元素时触发。
- `dragend`：在整个拖放操作结束时触发。

（2）目标元素：

- `dragenter`：在被拖放元素进入某元素时触发。

- `dragover`：在被拖放在某元素内移动时触发。
- `dragleave`：在被拖放元素移出目标元素是触发。
- `drop`：在目标元素完全接受被拖放元素时触发。

### 009：浏览器乱码的原因是什么？如何解决？

**乱码原因**：编码不一致导致（网页源代码是 `GBK` 编码，而内容是 `UTF-8`，这样浏览器打开就会出现乱码）;

**解决办法**：使用（IDE，编辑器）编辑网页内容；如果编码不一致，转码；

### 010：head 标签有什么作用，其中什么标签必不可少？

标签用于定义文档的头部，它是所有头部元素的容器。 标签中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

下面这些标签可用在 head 部分：`<base>`, `<link>`, `<meta>`, `<script>`, `<style>`, `<title>`。

其中 `<title>` 定义文档的标题，它是 head 部分中 **唯一必需** 的元素。

### 011：Canvas 和 SVG 的区别

**（1）SVG：** SVG（**S**calable **V**ector **G**raphics，可缩放矢量图形）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加 `Javascript` 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

其特点如下：

- 不依赖分辨率；
- 支持事件处理器；
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）；
- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）；
- 不适合游戏应用；

**（2）Canvas：** Canvas 是画布，通过 `Javascript` 来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。

其特点如下：

- 依赖分辨率；
- 不支持事件处理器；
- 文本渲染能力弱；
- 能够以 `.png` 或 `.jpg` 格式保存结果图像；
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘；

### 012：label 的作用是什么？如何使用？

`label` 标签用来定义表单控件的关系：当用户选择 `label` 标签时，浏览器会自动将焦点转到和 `label` 标签相关的表单控件上。

```html
<!-- 使用方法1： -->
<label for="mobile">Account:</label>
<input type="text" id="account"/>

<!-- 使用方法2： -->
<label>Password:<input type="text"/></label>
```

### 013：浏览器是如何对 HTML5 的离线储存资源进行管理和加载的？

- **在线的情况下**，浏览器发现 `html` 头部有 `manifest` 属性，它会请求 `manifest` 文件，如果是第一次访问页面 ，那么浏览器就会根据 `manifest` 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 `manifest` 文件与旧的 `manifest` 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。

- **离线的情况下**，浏览器会直接使用离线存储的资源。

## @CSS

### 001：CSS选择器及其优先级

| 选择器         | 格式                   | 优先级权重 |
| -------------- | ---------------------- | ---------- |
| `id` 选择器    | `#id`                  | 100        |
| 类选择器       | `#classname`           | 10         |
| 属性选择器     | `input[type='button']` | 10         |
| 伪类选择器     | `li:last-child`        | 10         |
| 标签选择器     | `div`                  | 1          |
| 伪元素选择器   | `li:after`             | 1          |
| 相邻兄弟选择器 | `h1 + p`               | 0          |
| 子选择器       | `ul > li`              | 0          |
| 后代选择器     | `li a`                 | 0          |
| 通配符选择器   | `*`                    | 0          |

对于选择器的 **优先级**：

- 标签选择器、伪元素选择器：`1`

- 类选择器、伪类选择器、属性选择器：`10`
- `id` 选择器：`100`
- 内联样式：`1000`

**注意事项：**

- `!important` 声明的样式的优先级最高；
- 如果优先级相同，则最后出现的样式生效；
- 继承得到的样式的优先级最低；
- 通用选择器（`*`）、子选择器（`>`）和相邻同胞选择器（`+`）并不在这四个等级中，所以它们的权值都为 `0` ；
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。

### 002：CSS 中可继承与不可继承属性有哪些？

**（1）继承属性**

- <u>字体</u> 系列属性：`font-family`、`font-weight`、`font-size`、`font-style`
- <u>文本</u> 系列属性：`text-indent`、`text-align`、`line-height`、`word-spacing`、`letter-spacing`、`text-transform`、`color`
- 元素可见性：`visibility`
- 列表布局属性：`list-style-type`、`ist-style-image` 等
- 光标属性：`cursor`

**（2）非继承属性**

- `display`
- 文本属性：`vertical-align`、`text-decoration`、`text-shadow`、`white-space`
- 盒子模型相关属性
- 背景属性
- 定位属性
- 轮廓样式属性
- ...

### 003：`inline`、`inline-block` 和 `block` 的区别？

- `inline`：元素不会独占一行，设置 `width`、`height` 属性无效。但可以设置水平方向的 `margin` 和 `padding` 属性，不能设置垂直方向的 `padding` 和`margin`；

- `inline-block`：将对象设置为 `inline` 对象，但对象的内容作为 `block` 对象呈现，之后的内联对象会被排列在同一行内

- `block`：独占一行，可以设置 `width`、`height`、`margin` 和 `padding` 属性；

### 004：隐藏元素的方法有哪些？

- `display: none`：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件
- `visibility: hidden`：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- `opacity: 0`：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
- `position: absolute`：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- `z-index: 负值`：使其他元素遮盖住该元素，以此来实现隐藏。
- `clip/clip-path`：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
- `transform: scale(0, 0)`：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

### 005：`link` 和 `@import` 的区别？

两者都是外部引用CSS的方式，它们的区别如下：

- `link` 是 HTML 标签，除了加载CSS外，还可以定义RSS等其他事务；`@import` 属于CSS 范畴，只能加载 CSS。
- `link` 引用CSS时，在页面载入时同时加载；`@import` 需要页面网页完全载入以后加载。
- `link` 是 HTML标签，无兼容问题；`@import` 是在CSS2.1提出的，低版本的浏览器不支持。
- `link` 支持使用 `JavaScript` 控制DOM去改变样式；而 `@import` 不支持。

### 006：`transition` 和 `animation` 的区别？

- `transition` 是 **过度属性**，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。
- `animation` 是 **动画属性**，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用 `@keyframe` 定义）完成动画。

### 007：`display:none` 与 `visibility:hidden` 的区别？

（1）在渲染树中

- `display:none` 会脱离文档流，渲染时不会占据任何空间；
- `visibility:hidden` 不会脱离文档流，渲染的元素还会占据相应的空间，只是内容不可见。

（2）是否是继承属性

- `display:none` 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- `visibility:hidden` 是继承属性，子孙节点消失是由于继承了 `hidden`，通过设置 `visibility:visible` 可以让子孙节点显示；

（3）修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改 `visibility` 属性只会造成本元素的重绘；

（4）如果使用读屏器，设置为 `display:none` 的内容不会被读取，设置为 `visibility:hidden` 的内容会被读取。

### 008：伪元素和伪类的区别和作用？

- **伪元素**：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为 “伪” 元素。例如：`::before`、`::after`、`::first-line`、`::first-letter`
- **伪类**：将 <u>特殊的效果</u> 添加到 <u>特定选择器</u>上。它是已有元素上添加类别的，不会产生新的元素。例如：`:hover`、`:first-child`

> **总结**： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。

### 009：谈谈你对 requestAnimationframe 的理解？

实现动画效果的方法比较多，`Javascript` 中可以通过定时器来实现，CSS3 中可以使用 `transition` 和 `animation` 来实现，HTML5 中的 `canvas` 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 `requestAnimationFrame`，顾名思义就是 **请求动画帧**。

MDN对该方法的描述：

> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

**语法形式：**

```javascript
window.requestAnimationFrame(callback);
```

- `callback`：**下一次重绘之前更新动画帧所调用的函数**（即上面所说的回调函数）。该回调函数会被传入`DOMHighResTimeStamp` 参数，它表示`requestAnimationFrame()`  开始去执行回调函数的时刻。该方法属于 **宏任务**，所以会在执行完微任务之后再去执行。

**取消动画：**

```javascript
cancelAnimationFrame(animationID);
```

- `animationID`：动画 `id`，该 `id` 来自于 `requestAnimationFrame` 的返回值。

**优势：**

- **CPU节能**：使用 `SetTinterval` 实现的动画，当页面被隐藏或最小化时，`SetTinterval` 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而 `RequestAnimationFrame` 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的 `RequestAnimationFrame` 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
- **函数节流**：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
- **减少DOM操作**：`requestAnimationFrame` 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。

**定时器执行动画的缺点**：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：

- 定时器任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；
- 定时器的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。

### 010：谈谈你对盒模型的理解？

CSS3 中的盒模型有两种：标准盒子模型、IE盒子模型。

盒模型都是由四个部分组成的，分别是：`margin`、`padding`、`border` 和 `content`。

标准盒模型和IE盒模型的区别在于设置 `width` 和 `height` 时，所对应的范围不同：

- 标准盒模型的 `width` 和 `height` 属性的范围只包含了`content`
- IE盒模型的 `width` 和 `height` 属性的范围包含了 `border`、`padding` 和 `content`。

可以通过修改元素的 `box-sizing` 属性来改变元素的盒模型：

- `box-sizeing: content-box` 表示标准盒模型（默认值）
- `box-sizeing: border-box` 表示IE盒模型（怪异盒模型）

### 011：li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？

浏览器会把 `inline` 内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

**解决办法：**

（1）为 `<li>` 设置 `float:left`。不足：有些容器是不能设置浮动，如左右切换的焦点图等。

（2）将所有 `<li>` 写在同一行。不足：代码不美观。

（3）将 `<ul>` 内的字符尺寸直接设为 0，即 `font-size:0`。不足：`<ul>`中的其他字符尺寸也被设为 0，需要额外重新设定其他字符尺寸，且在 `Safari` 浏览器依然会出现空白间隔。

（4）消除 `<ul>` 的字符间隔 `letter-spacing:-8px`，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认 `letter-spacing:normal`。

### 012：对 CSS Sprites 的理解？

`CSS Sprites`（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 `background-image`，`background-repeat`，`background-position` 属性的组合进行背景定位。

**优点：**

- 利用 `CSS Sprites` 能很好地减少网页的http请求，从而大大提高了页面的性能，这是 `CSS Sprites` 最大的优点；
- `CSS Sprites` 能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

**缺点：**

- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
- `CSS Sprites` 在开发的时候相对来说有点麻烦，需要借助 `photoshop` 或其他工具来对每个背景单元测量其准确的位置。
- 维护方面：`CSS Sprites` 在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的 `CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动 `CSS`。

### 013：CSS 优化和提高性能的方法有哪些？

（1）合并、压缩（GZIP）

（2）选择器优化嵌套，尽量避免层级过深

（3）避免使用通配符 `*` 、后代选择器（CSS选择器是从右到左进行匹配的）、CSS 表达式

（4）巧妙使用 CSS 继承机制

（5）拆分公共样式

（6）cssSprite

（7）避免使用 `@import`，建议使用 `link`

（8）如果使用了 `id` 选择器，就不需再加其他规则，因为 `id` 是唯一的

（9）属性值为0时，不加单位；属性值为浮动小数 `0.xx` 时，省略小数点前的 `0`

（10）去除无用的样式及空规则；

（11）慎重使用高性能属性：浮动、定位

（12）尽量减少页面重排、重绘

（13）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

### 014：单行、多行文本溢出隐藏

- 单行文本溢出

  ```css
  overflow: hidden; /* 溢出隐藏 */
  text-overflow: ellipsis;  /* 溢出用省略号显示 */ 
  white-space: nowrap;  /* 规定段落中的文本不进行换行 */    
  ```

- 多行文本溢出

  ```css
  overflow: hidden; /* 溢出隐藏 */           
  text-overflow: ellipsis; /* 溢出用省略号显示 */    
  display:-webkit-box; /* 作为弹性伸缩盒子模型显示 */    
  -webkit-box-orient:vertical; /* 设置伸缩盒子的子元素排列方式：从上到下垂直排列 */ 
  -webkit-line-clamp:3; /* 显示的行数 */
  ```

### 015：如何判断元素是否到达可视区域？

以图片显示为例：

![](./IMGS/iQ_view_area.png)

- `window.innerHeight` 是浏览器可视区的高度；

- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离；
- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

### 016：px、em、rem 的区别及使用场景

**三者的区别：**

- `px` 是固定的像素，一旦设置了就无法因为适应页面大小而改变。
- `em` 和 `rem` 相对于`px` 更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。
- `em` 是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 `rem` 是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。

**使用场景：**

- 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用 `px` 即可 。
- 对于需要适配各种移动设备，使用 `rem`，例如需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备。

### 017：响应式设计的概念及基本原理

**概念**：响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。

**原理**： 基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。

**兼容**：页面头部必须有 `meta` 声明的 `viewport`

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, viewport-fit=cover" />
```

### 018：为什么需要清除浮动？清除浮动的方式？

**浮动定义**：非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。

**浮动的工作原理：**

- 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）
- 浮动元素碰到包含它的边框或者其他浮动元素的边框停留

浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。

**浮动元素引起的问题？**

- 父元素的高度无法被撑开，影响与父元素同级的元素
- 与浮动元素同级的非浮动元素会跟随其后
- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构

**清除浮动的方式如下：**

- 给父级div定义 `height` 属性；

- 最后一个浮动元素之后添加一个空的div标签，并添加 `clear:both` 样式；

- 包含浮动元素的父级标签添加 `overflow:hidden` 或者 `overflow:auto`；

- 使用 `:after` 伪元素。由于IE6-7不支持 `:after`，使用 `zoom:1` 触发 `hasLayout**`；

  ```css
  .clearfix:after{
      content: "";
      display: block; 
      height: 0;
      clear: both;
  }
  .clearfix{
      *zoom: 1;
  }
  ```

### 019：如何解决 1px 问题？

1px 问题指的是：在一些  `Retina屏幕` 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：

```js
window.devicePixelRatio = 设备的物理像素 / CSS像素。
```

打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 `devicePixelRatio` 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：

![](./IMGS/iQ_device_pixel_ratio.png)

这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 **解决1px 问题的三种思路：**

#### 思路一：直接写 0.5px

```jsx
<div id="container" data-device={{window.devicePixelRatio}}></div>
```

```javascript
#container[data-device="2"] {
  border:0.5px solid #333
}
```

#### 思路二：伪元素先放大后缩小

#### 思路三：viewport 缩放

## @JavaScript

1. **JavaScript 实现对上传图片的压缩？**

   思路就是 File + Canvas 的 drawImage

   将用户上传的 File 对象，读写到画布（canvas）上，利用 Canvas 的 API 进行压缩，完成压缩之后再转成 File（Blob） 对象，上传到远程图片服务器；不过有时候我们也需要将一个 base64 字符串压缩之后再变为 base64 字符串传入到远程数据库或者再转成 File（Blob） 对象。

2. **谈一谈 JavaScript 的异步？**

   setTimeout、MutationObserver、postMessage、Promise、async、await、generator

3. **浏览器和 nodejs 事件循环？**

4. **手写节流与防抖** 

   ➦ 防抖函数

   ```js
   function debounce(callback, delay = 500) {
     let timer = null;
     return function (...args) {
       if (timer) {
         clearTimeout(timer); // 清除定时器
       }
       timer = setTimeout(() => {
         callback.apply(this, args);
         clearTimeout(timer);
       }, delay);
     };
   }
   ```

   ➦ 节流函数

   ```js
   function throttle(callback, delay = 500) {
     // 设置一个开关
     let on = true;
     return function () {
       if (!on) return; // 如果开关已经关掉了就不用往下了
       on = false;
       setTimeout(() => {
         callback.apply(this, arguments);
         on = true; // 执行完才打开开关
       }, delay);
     };
   }
   ```

   

5. **手写bind函数**

   [参考 >>](https://github.com/sisterAn/JavaScript-Algorithms/issues/81)

   ```js
   Function.prototype.bind = function (context) {
     if (typeof this !== "function") {
       throw new Error("Is not function.");
     }
     // this 指向调用者
     var self = this;
     // 处理参数/因为第1个参数是指定的this,所以只截取第1个之后的参数
     var args = Array.prototype.slice.call(arguments, 1);
     // 创建一个空对象
     var fNOP = function () {};
     // 创建返回函数
     var fBound = function () {
       // 获取 bind 返回函数的参数
       var bindArgs = Array.prototype.slice.call(arguments);
       // 然后同传入参数合并成一个参数数组，并作为 self.apply() 的第二个参数
       return self.apply(
         this instanceof fNOP ? this : context,
         args.concat(bindArgs)
       );
     };
     // 空对象的原型指向绑定函数的原型
     fNOP.prototype = this.prototype;
     // 空对象的实例赋值给 fBound.prototype
     fBound.prototype = new fNOP();
     return fBound;
   };
   ```

6. **严格模式**

   this 的 undefined，禁止 with，arguments 不允许更改，给只读对象赋值抛异常，变量需要先声明，call，apply 第一个参数不会被转换...

7. **数据类型转换**

   ```js
   const result = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
   ```

   问：result的值是什么？

8. **Js基本数据类型有哪些？**

   - 原始数据类型：Number，String，Boolean，BigInt，Symbols，Null，Undefined

   - 对象数据类型：Object，Function，Date，Array，Maps，Sets，JSON

9. **Ajax如何使用？**

   ```js
   // 1. 创建请求对象
   let xhr = new XMLHttpRequest();
   // 2. 配置请求
   // -> xhr.open(method, url, sync)
   xhr.open("GET / POST", "http://127.0.0.1:8081/heros", true);
   // -> 设置响应类型
   xhr.responseType = "json";
   // -> 设置请求超时时间
   xhr.timeout = 10000;
   // 3. 发送请求
   xhr.send(params?);
   // 4. 事件监听
   // -> 请求完成
   xhr.onload = function() {
       // readyState 请求状态
       // status 状态码
       if(xhr.readyState == 4 && xhr.status == 200) {
           // 打印结果
           console.log(xhr.response);
       }else {
           console.log(`XMLHttpRequest_ERROR_STATUS：${xhr.status}`);
       }
   }
   ```

10. **如何判断一个数据是NaN？**

    - 利用 `NaN` 是唯一一个不等于自身的特点

      ```js
      function _isNaN(val) {
        if (val !== val) {
          return true;
        }
        return false;
      }
      ```

    - 利用 ES6 中提供的 `Object.is()` 方法

      ```js
      var a = "string";
      var b = 2;
      var c = a/b;  // NaN
      
      Object.is(a, NaN);	// false
      Object.is(b, NaN);	// false
      Object.is(c, NaN);	// true
      ```

    - 使用 `isNaN` （并不推荐）

      ```js
      function _isNaN(val) {
        if (typeof val === "number" && isNaN(val)) {
          return true;
        }
        return false;
      }
      ```

      > 提示：`isNaN()` 的参数如果不是 Number 类型，则会先把参数进行一次 Number 转换，所以如果直接使用，当传入字符串时，也会返回 true，即 `isNaN('str'); // true` 。

11. **闭包是什么？有什么特性？对页面会有什么影响**

12. **`[1, 2, 3].map(parseInt)` 输出什么？**

- Js中常见的内存泄漏：
- 事件委托是什么？如何确定事件源（Event.target 谁调用谁就是事件源）
- 什么是事件冒泡？
- 本地存储与cookie的区别
- ES6新特性
- Let与var与const的区别
- 数组方法有哪些请简述
- 请掌握2种以上数组去重的方式
- 什么是面向对象请简述
- 普通函数和构造函数的区别
- 请简述原型 / 原型链 /（原型）继承
- Promise的理解
- 请简述async的用法
- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
- Js中.call()与.apply()区别
- 为什么会造成跨域/请简述同源策略
- This指向
- 什么是jsonp工作原理是什么？他为什么不是真正的ajax
- 请写出一个简单的类与继承
- 同步与异步的区别/阻塞与非阻塞区别
- 为什么js是弱类型语言
- 箭头函数与普通函数的区别
- For循环与map循环有什么区别
- 原型和继承，prototype，call和apply继承的区别
- 深浅拷贝是什么如何实现？
- 什么时候用深拷贝 /浅拷贝
- 什么是js内存泄露？
- 什么是csrf攻击
- 预加载和懒加载的区别，预加载在什么时间加载合适
- Js的函数节流和函数防抖的区别

## @浏览器，HTTP相关

- http是什么？有什么特点

- HTTP协议和HTTPS区别
- 请简述ajax的执行过程 以及常见的HTTP状态码
- Get和post不同
- 请输出三种减少页面加载时间的方式
- 重绘和回流是什么
- 你如何对网站的文件和资源进行优化？

## @VUE

> **1. Vue的优点？Vue的缺点？**

优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开。

缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长。

> **2. 为什么说Vue是一个渐进式框架？**

渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以。

> **3. Vue跟React的异同点？**

相同点：

- 都使用了虚拟dom
- 组件化开发
- 都是单向数据流（父子组件之间，不建议子修改父传下来的数据）
- 都支持服务端渲染

不同点：

- React的JSX，Vue的template
- 数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty/3.x proxy)
- React单向绑定，Vue双向绑定
- React的Redux，Vue的Vuex

> **4. MVVM是什么？和MVC有何区别呢？**

MVC

- Model(模型)：负责从数据库中取数据
- View(视图)：负责展示数据的地方
- Controller(控制器)：用户交互的地方，例如点击事件等等
- 思想：Controller将Model的数据展示在View上

![](./IMGS/mvc.jpg)

MVVM

- VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。
- 思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）

![](./IMGS/mvvm-pattern.png)

区别：

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性。

Vue是不是MVVM框架？

Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的`ref`可以做到这点



> **5. Vue和jQuery的区别在哪？为什么放弃jQuery用Vue？**

- jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可
- jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能
- Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上
- Vue集成的一些库，大大提高开发效率，比如Vuex，Router等



> **6. 为什么data是个函数并且返回一个对象呢？**

`data`之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行`data函数`并返回新的数据对象，这样，可以避免多处调用之间的`数据污染`。



> **7. 使用过哪些Vue的修饰符呢？**

![](./IMGS/vue_qualifier.png)

> **8. 组件之间的传值方式有哪些？**

- 父组件传值给子组件，子组件使用`props`进行接收
- 子组件传值给父组件，子组件使用`$emit+事件`对父组件进行传值
- 组件中可以使用`$parent`和`$children`获取到父组件实例和子组件实例，进而获取数据
- 使用`$attrs`和`$listeners`，在对一些组件进行二次封装时可以方便传值，例如A->B->C
- 使用`$refs`获取组件实例，进而获取数据
- 使用`Vuex`进行状态管理
- 使用`eventBus`进行跨组件触发事件，进而传递数据
- 使用`provide`和`inject`，官方建议我们不要用这个，我在看`ElementUI`源码时发现大量使用
- 使用浏览器本地缓存，例如`localStorage`

> **9.  路由有哪些模式呢？又有什么不同呢？**

- hash模式：通过 `#号` 后面的内容的更改，触发 `hashchange` 事件，实现路由切换。
- history模式：通过 `pushState` 和 `replaceState` 切换url，触发 `popstate` 事件，实现路由切换，需要后端配合（nginx-try_files )。

> **10. 如何设置动态class，动态style？**

- 动态class对象：`<div :class="{ 'is-active': true, 'red': isRed }"></div>`
- 动态class数组：`<div :class="['is-active', isRed ? 'red' : '' ]"></div>`
- 动态style对象：`<div :style="{ color: textColor, fontSize: '18px' }"></div>`
- 动态style数组：`<div :style="[{ color: textColor, fontSize: '18px' }, { fontWeight: '300' }]"></div>`

> **11. v-if和v-show有何区别？**

- 1.`v-if`是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁
- 2.`v-show`是通过控制dom元素的css样式来实现显隐，不会销毁
- 3.频繁或者大数量显隐使用`v-show`，否则使用`v-if`

## @REACT

- fetch VS ajax VS axios
- React事件处理—修改this指向
- 请简述你对react的理解
- react组件之间的数据传递
- Vue与react区别
- 请简述虚拟dom与diff算法
- 调用 setState 之后发生了什么？
- react 生命周期函数
- 为什么虚拟 dom 会提高性能?(必考)
- State与props区别
- shouldComponentUpdate 是做什么的
- react diff 原理
- 何为受控组件
- 调用 super(props) 的目的是什么
- React 中构建组件的方式

## @小程序

- 小程序的优势
- 小程序的页面构成
- 小程序的生命周期
- 小程序如何请求数据
- 如何提高小程序的首屏加载时间
- 请简述你经常使用的小程序的组件
- wxss与css的区别请简述
- 怎么优化小程序
- 小程序如何显示用户头像与用户名
- 请谈谈小程序的双向绑定和vue的异同？

## @工程化

1. **介绍一下Tree shaking 及其工作原理**

   [参考 >>](https://segmentfault.com/a/1190000038962700)

   Tree shaking 是一种通过<u>清除多余代码方式来优化项目打包体积</u>的技术，专业术语叫 Dead code elimination

   - `ES6 Module`引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
   - 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

2. **你对 vite 熟悉，和 webpack 区别**

   webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS 

3. 

## @TypeScript

[参考 >>](https://mp.weixin.qq.com/s/QeMr1La-1kqUaxGj8JmxHA)

1. **ts类型中的 `?`、`<>`意思是什么？**

   - `?`：可选类型，strictNullChecks（严格空值）模式下，`obj?:?number` 表示接收的类型为 `number | null`
   - `<>`：泛型

2. **什么是 duck typing?**

   是动态语言中的一种类型推断风格风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。

3. **constructor之前的变量定义是什么？**

   是属性

   ```markdown
   property
   constructor
   method
   ```

4. **declare是什么？**

   declare 是ts中用于写定义文件的关键字，declare可以定义全局变量，全局函数，全局命名空间，class等

5. **ts中unknown, void, null和undefined，never区别是什么？**

   - null、undefined就是js中的意思；
   - any：任意类型，谨慎使用，避免使typescript变成anyscript ；
   - unknown：与any类似，但是比any更加安全；
   - void：通常用于返回值为空的函数；
   - never：never occur 从来不会发生的类型，例如永远不会有结果的，抛出异常或者死循环；

6. **ts中的泛型约束是什么？**

   使用泛型之后，能处理的类型就扩大了无限大，有点失控，所以产生了一个约束的概念。我们可以通过`extends`关键字进行约束。

7. **数组类型的两种定义方式**

   - Array后面加一个<>，<>内声明元素类型
   - 类型[]

   ```typescript
   let arr1: Array<string>;
   let arr2: string[];
   ```

8. **ts中的类型断言**

   TypeScript允许我们覆盖推断和分析出的视图类型为我们想要的任意方式，这种机制叫做类型断言（Type Assertion），类型断言会告诉编译器你比它更加知道具体是哪种类型，编译器不用再二次推断了。类型断言往往是发生在编译器编译期间，用于提示编译器如何分析我们的代码。

9. **泛型函数与泛型接口**

   **➦ 泛型函数**

   输入与输出一致

   ```js
   function log<T>(value: T): T {
     return value;
   }
   ```

   **➦ 泛型接口**

   ```typescript
   interface Log<T> {
     (value: T): T
   }
   ```

10. **如何理解 `as const`（const assertions/const断言）？**

    - 为了解决let赋值问题的，将一个mutable的变量改为readonly。
    - 避免将类型推断为联合类型。
    
11. **declare global是什么意思？**

    是为了在全局命名空间做声明，比如为对象增加一个未定义的属性。

    ```typescript
    declare global {
      interface Window {
        _html: any;
      }
    }
    ```

    > 提示：注意global作用域只能用于导出模块或者外部的模块声明

12. **typescript中的 `&` 是什么意思?**

    交叉类型

13. **interface与type的区别是什么？**

    - interface可以继承（比如用extends），type不可以
    - interface可以实现有多个合并声明，type不可以

