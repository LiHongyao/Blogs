# 面试题集锦

## @Web

### **001：前端性能优化**

前端性能评级工具： [PageSpeed >>](https://developers.google.com/speed/pagespeed/insights/)  / YSlow

```markdown
# CSS:
- 合并、压缩CSS，尽量减少http请求；
- 将css文件防止在页面最上面（head标签对内）；
- 移除不用的CSS;
- 避免使用CSS表达式；
- 选择器优化嵌套，避免层级过深；
- 充分利用CSS继承属性或者抽象提取公共样式，减少代码量；
- 属性值为0时不加单位；
- 属性值小于1的小数时省略小数点前面的0；
- 使用CSS Sprites将多张图片拼接成一张图片，通过CSS background 属性来访问图片内容；

# JavaScript
- 防抖、节流；
- 长列表渲染；
- 图片懒加载（src）
- 避免使用闭包，如果使用闭包时，在函数结尾手动删除不需要的局部变量，尤其在缓存dom节点的情况下；
- DOM操作优化：
  * 批量添加DOM可先 createElement 创建并添加节点，最后一次性加入DOM;
  * 批量绑定事件，使用 事件委托 实现，利用事件冒泡特性；
  * 使用innerHTML 替代 appendChild；
  * 处理样式尽量操作class，而不是直接操作 style 属性，减少重排（Reflow）；
  
# 网络
- 减少HTTP 请求数量；
- 利用浏览器缓存，公共依赖包单独打包/单文件在一起，避免重复请求；
- 减少cookie大小，尽量使用 localStorage 代替；
- CDN托管静态文件；
- 开启Gzip压缩；
```

### 002：浏览器内核

主要分为 `渲染引擎` 和 `JS引擎` 两部分，其中：

- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
- JS引擎：解析和执行`javascript`来实现网页的动态效果。

> 提示：最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

### 003：常见浏览器内核

- Trident：IE
- Gecko：Firefox
- Webkit：Safari
- Blink：Chrome/Opera/Edge

## @HTML

### 001：`src` 和 `href` 的区别？

`src` 和 `href` 都是 **用来引用外部的资源**，它们的区别如下：

- `src`：表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。`src` 会将其指向的资源下载并应⽤到⽂档内，如请求 `js` 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 `js` 脚本会放在页面底部。
- `href`：表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在 `a`、`link` 等标签上。 

### 002：对HTML语义化的理解？

语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。

语义化的优点如下：

- 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
- 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

常见的语义化标签：

```html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

### 003：DOCTYPE（⽂档类型） 的作⽤？

`DOCTYPE` 是 HTML5 中一种标准通用标记语言的 **文档类型声明**，它的目的是告诉浏览器（解析器）应该以什么样（`html`或`xhtml`）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 `CSS` 代码甚⾄ `JavaScript` 脚本的解析。它必须声明在 `HTML`⽂ 档的第⼀⾏。

浏览器渲染页面的两种模式（可通过 `document.compatMode` 获取）：

- `CSS1Compat`：**标准模式**（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 
- `BackCompat`：**怪异模式(混杂模式)**(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。

### 004：script  标签中 `defer` 和 `async` 的区别？

如果没有 `defer` 或 `async` 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

`defer` 和 `async` 属性都是去 **异步加载** 外部的 `JS` 脚本文件，它们都不会阻塞页面的解析，其区别如下：

- **执行顺序：** 
  - 多个带 `async` 属性的标签，不能保证加载的顺序；
  - 多个带 `defer` 属性的标签，按照加载顺序执行；
- **脚本是否并行执行：**
  - `async` 属性，表示后续文档的加载和执行与 `js` 脚本的加载和执行是并行进行的，即异步执行；
  - `defer` 属性，加载后续文档的过程和`js` 脚本的加载（此时仅加载不执行）是并行进行的（异步），`js`脚本需要等到文档所有元素解析完成之后才执行，`DOMContentLoaded` 事件触发执行之前。

### 005：常⽤的 meta 标签有哪些？

`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些 `name` 作为大家使用的共识，开发者还可以自定义 `name`。

常用的meta标签：

1）`charset`，用来描述HTML文档的编码类型：

```html
<meta charset="UTF-8" >
```

2）`keywords`，页面关键词：

```html
<meta name="keywords" content="关键词" />
```

3）`description`，页面描述：

```html
<meta name="description" content="页面描述内容" />
```

4）`refresh`，页面重定向和刷新：

```html
<meta http-equiv="refresh" content="0;url=" />
```

5）`viewport`，适配移动端，可以控制视口的大小和比例：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, viewport-fit=cover" />
```

6）搜索引擎索引方式：

```html
<meta name="robots" content="index,follow" />
```

### 006：HTML5有哪些更新？

（1）新增语义化标签：==nav、header、footer、aside、section、article==

（2）音频、视频标签：audio、video

（3）数据存储：localStorage、sessionStorage

（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） 

（5）input 标签新增属性：placeholder、autocomplete、autofocus、required

（6）history API：go、forward、back、pushstate

### 007：渐进增强和优雅降级之间的区别？

- **渐进增强**：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
- **优雅降级**：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

二者的区别：

- 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
- 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。

> **优雅降级** 观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。

> **渐进增强** 观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。

### 008：说一下 HTML5 drag API?

1）被拖放元素：

- `dragstart`：在开始拖放被拖放元素时触发。

- `darg`：在正在拖放被拖放元素时触发。
- `dragend`：在整个拖放操作结束时触发。

2）目标元素：

- `dragenter`：在被拖放元素进入某元素时触发。

- `dragover`：在被拖放在某元素内移动时触发。
- `dragleave`：在被拖放元素移出目标元素是触发。
- `drop`：在目标元素完全接受被拖放元素时触发。

### 009：浏览器乱码的原因是什么？如何解决？

产生乱码的原因：

- 网页源代码是 `gbk` 的编码，而内容中的中文字是 `utf-8` 编码的，这样浏览器打开即会出现 `html` 乱码，反之也会出现乱码；
- `html` 网页编码是 `gbk`，而程序从数据库中调出呈现是 `utf-8` 编码的内容也会造成编码乱码；
- 浏览器不能自动检测网页编码，造成网页乱码。

解决办法：

- 使用软件编辑 HTML 网页内容；
- 如果网页设置编码是 `gbk`，而数据库储存数据编码格式是 `UTF-8`，此时需要程序查询数据库数据显示数据前进程序转码；
- 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。

## @CSS

- 请简述css盒子模型
- CSS3新增的特性

- 视频/音频标签的使用
- 清除浮动的方式有哪些？请说出各自的优点
- 定位的属性值有何区别
- 子元素如何在父元素中居中
- Border-box与content-box的区别
- 元素垂直居中
- 如何让chrome浏览器显示小于12px的文字
- CSS选择器有哪些，那些属性可以继承，优先级如何计算？
- CSS3新增的伪类有哪些？
- 网页中有大量图片加载很慢 你有什么办法进行优化？
- 行内元素/块级元素有哪些？
- 浏览器的标准模式和怪异模式区别？
- Margin和padding在什么场合下使用
- 弹性盒子布局属性有那些请简述?
- 怎么实现标签的禁用
- Flex布局原理
- px，rem，em的区别
- 网页的三层结构有哪些
- 请简述媒体查询
- 三栏布局方式两边固定中间自适应
- Doctype作用
- CSS 预处理 sass less 是什么？为什么使用他们
- 怎么转换less为css

## ➲ JavaScript

1. **JavaScript 实现对上传图片的压缩？**

   思路就是 File + Canvas 的 drawImage

   将用户上传的 File 对象，读写到画布（canvas）上，利用 Canvas 的 API 进行压缩，完成压缩之后再转成 File（Blob） 对象，上传到远程图片服务器；不过有时候我们也需要将一个 base64 字符串压缩之后再变为 base64 字符串传入到远程数据库或者再转成 File（Blob） 对象。

2. **谈一谈 JavaScript 的异步？**

   setTimeout、MutationObserver、postMessage、Promise、async、await、generator

3. **浏览器和 nodejs 事件循环？**

4. **手写节流与防抖** 

   ➦ 防抖函数

   ```js
   function debounce(callback, delay = 500) {
     let timer = null;
     return function (...args) {
       if (timer) {
         clearTimeout(timer); // 清除定时器
       }
       timer = setTimeout(() => {
         callback.apply(this, args);
         clearTimeout(timer);
       }, delay);
     };
   }
   ```

   ➦ 节流函数

   ```js
   function throttle(callback, delay = 500) {
     // 设置一个开关
     let on = true;
     return function () {
       if (!on) return; // 如果开关已经关掉了就不用往下了
       on = false;
       setTimeout(() => {
         callback.apply(this, arguments);
         on = true; // 执行完才打开开关
       }, delay);
     };
   }
   ```

   

5. **手写bind函数**

   [参考 >>](https://github.com/sisterAn/JavaScript-Algorithms/issues/81)

   ```js
   Function.prototype.bind = function (context) {
     if (typeof this !== "function") {
       throw new Error("Is not function.");
     }
     // this 指向调用者
     var self = this;
     // 处理参数/因为第1个参数是指定的this,所以只截取第1个之后的参数
     var args = Array.prototype.slice.call(arguments, 1);
     // 创建一个空对象
     var fNOP = function () {};
     // 创建返回函数
     var fBound = function () {
       // 获取 bind 返回函数的参数
       var bindArgs = Array.prototype.slice.call(arguments);
       // 然后同传入参数合并成一个参数数组，并作为 self.apply() 的第二个参数
       return self.apply(
         this instanceof fNOP ? this : context,
         args.concat(bindArgs)
       );
     };
     // 空对象的原型指向绑定函数的原型
     fNOP.prototype = this.prototype;
     // 空对象的实例赋值给 fBound.prototype
     fBound.prototype = new fNOP();
     return fBound;
   };
   ```

6. **严格模式**

   this 的 undefined，禁止 with，arguments 不允许更改，给只读对象赋值抛异常，变量需要先声明，call，apply 第一个参数不会被转换...

7. **数据类型转换**

   ```js
   const result = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
   ```

   问：result的值是什么？

8. **Js基本数据类型有哪些？**

   - 原始数据类型：Number，String，Boolean，BigInt，Symbols，Null，Undefined

   - 对象数据类型：Object，Function，Date，Array，Maps，Sets，JSON

9. **Ajax如何使用？**

   ```js
   // 1. 创建请求对象
   let xhr = new XMLHttpRequest();
   // 2. 配置请求
   // -> xhr.open(method, url, sync)
   xhr.open("GET / POST", "http://127.0.0.1:8081/heros", true);
   // -> 设置响应类型
   xhr.responseType = "json";
   // -> 设置请求超时时间
   xhr.timeout = 10000;
   // 3. 发送请求
   xhr.send(params?);
   // 4. 事件监听
   // -> 请求完成
   xhr.onload = function() {
       // readyState 请求状态
       // status 状态码
       if(xhr.readyState == 4 && xhr.status == 200) {
           // 打印结果
           console.log(xhr.response);
       }else {
           console.log(`XMLHttpRequest_ERROR_STATUS：${xhr.status}`);
       }
   }
   ```

10. **如何判断一个数据是NaN？**

    - 利用 `NaN` 是唯一一个不等于自身的特点

      ```js
      function _isNaN(val) {
        if (val !== val) {
          return true;
        }
        return false;
      }
      ```

    - 利用 ES6 中提供的 `Object.is()` 方法

      ```js
      var a = "string";
      var b = 2;
      var c = a/b;  // NaN
      
      Object.is(a, NaN);	// false
      Object.is(b, NaN);	// false
      Object.is(c, NaN);	// true
      ```

    - 使用 `isNaN` （并不推荐）

      ```js
      function _isNaN(val) {
        if (typeof val === "number" && isNaN(val)) {
          return true;
        }
        return false;
      }
      ```

      > 提示：`isNaN()` 的参数如果不是 Number 类型，则会先把参数进行一次 Number 转换，所以如果直接使用，当传入字符串时，也会返回 true，即 `isNaN('str'); // true` 。

11. **闭包是什么？有什么特性？对页面会有什么影响**

12. **`[1, 2, 3].map(parseInt)` 输出什么？**

- Js中常见的内存泄漏：
- 事件委托是什么？如何确定事件源（Event.target 谁调用谁就是事件源）
- 什么是事件冒泡？
- 本地存储与cookie的区别
- ES6新特性
- Let与var与const的区别
- 数组方法有哪些请简述
- 请掌握2种以上数组去重的方式
- 什么是面向对象请简述
- 普通函数和构造函数的区别
- 请简述原型 / 原型链 /（原型）继承
- Promise的理解
- 请简述async的用法
- 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
- Js中.call()与.apply()区别
- 为什么会造成跨域/请简述同源策略
- This指向
- 什么是jsonp工作原理是什么？他为什么不是真正的ajax
- 请写出一个简单的类与继承
- 同步与异步的区别/阻塞与非阻塞区别
- 为什么js是弱类型语言
- 箭头函数与普通函数的区别
- For循环与map循环有什么区别
- 原型和继承，prototype，call和apply继承的区别
- 深浅拷贝是什么如何实现？
- 什么时候用深拷贝 /浅拷贝
- 什么是js内存泄露？
- 什么是csrf攻击
- 预加载和懒加载的区别，预加载在什么时间加载合适
- Js的函数节流和函数防抖的区别

## ➲ jQuery

- 什么是jQuery？
- 为什么要使用jQuery？jquery有哪些好处？
- Jquery选择器有哪些
- Jquery插入节点的方法
- jQuery对象和DOM对象是怎样转换的
- jQuery中.get()提交和.post()提交的区别
- 怎么使用jQuery中的动画
- jQuery中如何来获取和设置属性
- 如何来设置和获取HTML和文本的值？
- jQuery中有哪些方法可以遍历节点？
- $(this) 和 this 关键字在 jQuery 中有何不同？
- jQuery 里的 each() 是什么函数？你是如何使用它的？
- Query中的Delegate()函数有什么作用？

## ➲ 浏览器，HTTP相关

- http是什么？有什么特点

- HTTP协议和HTTPS区别
- 请简述ajax的执行过程 以及常见的HTTP状态码
- Get和post不同
- 请输出三种减少页面加载时间的方式
- 重绘和回流是什么
- 你如何对网站的文件和资源进行优化？

## ➲ VUE

> **1. Vue的优点？Vue的缺点？**

优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开。

缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长。

> **2. 为什么说Vue是一个渐进式框架？**

渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以。

> **3. Vue跟React的异同点？**

相同点：

- 都使用了虚拟dom
- 组件化开发
- 都是单向数据流（父子组件之间，不建议子修改父传下来的数据）
- 都支持服务端渲染

不同点：

- React的JSX，Vue的template
- 数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty/3.x proxy)
- React单向绑定，Vue双向绑定
- React的Redux，Vue的Vuex

> **4. MVVM是什么？和MVC有何区别呢？**

MVC

- Model(模型)：负责从数据库中取数据
- View(视图)：负责展示数据的地方
- Controller(控制器)：用户交互的地方，例如点击事件等等
- 思想：Controller将Model的数据展示在View上

![](./IMGS/mvc.jpg)

MVVM

- VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。
- 思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）

![](./IMGS/mvvm-pattern.png)

区别：

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性。

Vue是不是MVVM框架？

Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的`ref`可以做到这点



> **5. Vue和jQuery的区别在哪？为什么放弃jQuery用Vue？**

- jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可
- jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能
- Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上
- Vue集成的一些库，大大提高开发效率，比如Vuex，Router等



> **6. 为什么data是个函数并且返回一个对象呢？**

`data`之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行`data函数`并返回新的数据对象，这样，可以避免多处调用之间的`数据污染`。



> **7. 使用过哪些Vue的修饰符呢？**

![](./IMGS/vue_qualifier.png)

> **8. 组件之间的传值方式有哪些？**

- 父组件传值给子组件，子组件使用`props`进行接收
- 子组件传值给父组件，子组件使用`$emit+事件`对父组件进行传值
- 组件中可以使用`$parent`和`$children`获取到父组件实例和子组件实例，进而获取数据
- 使用`$attrs`和`$listeners`，在对一些组件进行二次封装时可以方便传值，例如A->B->C
- 使用`$refs`获取组件实例，进而获取数据
- 使用`Vuex`进行状态管理
- 使用`eventBus`进行跨组件触发事件，进而传递数据
- 使用`provide`和`inject`，官方建议我们不要用这个，我在看`ElementUI`源码时发现大量使用
- 使用浏览器本地缓存，例如`localStorage`

> **9.  路由有哪些模式呢？又有什么不同呢？**

- hash模式：通过 `#号` 后面的内容的更改，触发 `hashchange` 事件，实现路由切换。
- history模式：通过 `pushState` 和 `replaceState` 切换url，触发 `popstate` 事件，实现路由切换，需要后端配合（nginx-try_files )。

> **10. 如何设置动态class，动态style？**

- 动态class对象：`<div :class="{ 'is-active': true, 'red': isRed }"></div>`
- 动态class数组：`<div :class="['is-active', isRed ? 'red' : '' ]"></div>`
- 动态style对象：`<div :style="{ color: textColor, fontSize: '18px' }"></div>`
- 动态style数组：`<div :style="[{ color: textColor, fontSize: '18px' }, { fontWeight: '300' }]"></div>`

> **11. v-if和v-show有何区别？**

- 1.`v-if`是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁
- 2.`v-show`是通过控制dom元素的css样式来实现显隐，不会销毁
- 3.频繁或者大数量显隐使用`v-show`，否则使用`v-if`

## ➲ REACT

- fetch VS ajax VS axios
- React事件处理—修改this指向
- 请简述你对react的理解
- react组件之间的数据传递
- Vue与react区别
- 请简述虚拟dom与diff算法
- 调用 setState 之后发生了什么？
- react 生命周期函数
- 为什么虚拟 dom 会提高性能?(必考)
- State与props区别
- shouldComponentUpdate 是做什么的
- react diff 原理
- 何为受控组件
- 调用 super(props) 的目的是什么
- React 中构建组件的方式

## ➲ 小程序

- 小程序的优势
- 小程序的页面构成
- 小程序的生命周期
- 小程序如何请求数据
- 如何提高小程序的首屏加载时间
- 请简述你经常使用的小程序的组件
- wxss与css的区别请简述
- 怎么优化小程序
- 小程序如何显示用户头像与用户名
- 请谈谈小程序的双向绑定和vue的异同？

## ➲ 工程化

1. **介绍一下Tree shaking 及其工作原理**

   [参考 >>](https://segmentfault.com/a/1190000038962700)

   Tree shaking 是一种通过<u>清除多余代码方式来优化项目打包体积</u>的技术，专业术语叫 Dead code elimination

   - `ES6 Module`引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
   - 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

2. **你对 vite 熟悉，和 webpack 区别**

   webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS 

3. 

## ➲ TypeScript

[参考 >>](https://mp.weixin.qq.com/s/QeMr1La-1kqUaxGj8JmxHA)

1. **ts类型中的 `?`、`<>`意思是什么？**

   - `?`：可选类型，strictNullChecks（严格空值）模式下，`obj?:?number` 表示接收的类型为 `number | null`
   - `<>`：泛型

2. **什么是 duck typing?**

   是动态语言中的一种类型推断风格风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。

3. **constructor之前的变量定义是什么？**

   是属性

   ```markdown
   property
   constructor
   method
   ```

4. **declare是什么？**

   declare 是ts中用于写定义文件的关键字，declare可以定义全局变量，全局函数，全局命名空间，class等

5. **ts中unknown, void, null和undefined，never区别是什么？**

   - null、undefined就是js中的意思；
   - any：任意类型，谨慎使用，避免使typescript变成anyscript ；
   - unknown：与any类似，但是比any更加安全；
   - void：通常用于返回值为空的函数；
   - never：never occur 从来不会发生的类型，例如永远不会有结果的，抛出异常或者死循环；

6. **ts中的泛型约束是什么？**

   使用泛型之后，能处理的类型就扩大了无限大，有点失控，所以产生了一个约束的概念。我们可以通过`extends`关键字进行约束。

7. **数组类型的两种定义方式**

   - Array后面加一个<>，<>内声明元素类型
   - 类型[]

   ```typescript
   let arr1: Array<string>;
   let arr2: string[];
   ```

8. **ts中的类型断言**

   TypeScript允许我们覆盖推断和分析出的视图类型为我们想要的任意方式，这种机制叫做类型断言（Type Assertion），类型断言会告诉编译器你比它更加知道具体是哪种类型，编译器不用再二次推断了。类型断言往往是发生在编译器编译期间，用于提示编译器如何分析我们的代码。

9. **泛型函数与泛型接口**

   **➦ 泛型函数**

   输入与输出一致

   ```js
   function log<T>(value: T): T {
     return value;
   }
   ```

   **➦ 泛型接口**

   ```typescript
   interface Log<T> {
     (value: T): T
   }
   ```

10. **如何理解 `as const`（const assertions/const断言）？**

    - 为了解决let赋值问题的，将一个mutable的变量改为readonly。
    - 避免将类型推断为联合类型。
    
11. **declare global是什么意思？**

    是为了在全局命名空间做声明，比如为对象增加一个未定义的属性。

    ```typescript
    declare global {
      interface Window {
        _html: any;
      }
    }
    ```

    > 提示：注意global作用域只能用于导出模块或者外部的模块声明

12. **typescript中的 `&` 是什么意思?**

    交叉类型

13. **interface与type的区别是什么？**

    - interface可以继承（比如用extends），type不可以
    - interface可以实现有多个合并声明，type不可以

