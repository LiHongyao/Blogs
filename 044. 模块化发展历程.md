一、前言

模块化是为了处理全局污染和依赖管理混乱的问题（用来抽离公共代码，隔离作用域，避免变量冲突等）。

因为一开始 JavaScript 本身没有提供模块化的机制，所以才会衍生出 `commonJS`、`AMD`、`CMD` 和 `UMD` 这么多模块化规范。JavaScript 在 ES6 时原生提供了 `import` 和 `export` 模块化机制（ `ESModule` ）。

# 二、发展历程

[思维导图 >>](https://www.processon.com/view/link/61c938021e0853641513e7e0)

## 1. 混沌时代（IIFE - 自调用函数）

早期并无 **模块化** 的概念，我们将所有的 JavaScript 文件放在一块，代码执行顺序就按照文件顺序执行。

```html
<script src="./libs/jquery-3.6.0.min.js"></script>
<script src="./libs/jquery.progress.min.js"></script>
<script src="./libs/jquery.countup.min.js"></script>
<script src="./js/render.js"></script>
<script src="./js/index.js"></script>
```

这样做的缺点就是 **污染全局作用域**，每一个模块都是暴露在全局中的，容易产生 **命名冲突**，还要 **手动处理各代码的依赖关系**。

因此，我们使用自调用函数来编写模块化，其特点就是：**在一个单独的函数作用域中执行代码，避免变量冲突。**

```javascript
(function() {
  // code in here.
})()
```

> 温馨提示：当然，在早起时候，一个函数 或者 一个对象也可以理解为一个模块 。

## 2. commonJS

2009年，美国程序员 `Ryan Dahl` 创造了[node.js](https://nodejs.org/) 项目，将 JavaScript 语言用于服务器端编程。这标志 `JavaScript 模块化编程` 正式诞生。node.js 的模块系统，就是参照 CommonJS 规范实现的。

CommonJS 是一个 JavaScript 模块化的规范， 一般在服务端（`node.js`）中用来 **同步加载模块**，每个文件都可以是一个模块，它对于模块的依赖发生在代码运行阶段。浏览器也可使用，不过需要借助 webpack 等构建工具提前编译打包处理。

commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。所以 `commonJS  不适合在浏览器端使用`。

**# API**

- 导出：`module.exports = {}` | `exports.xxx = 'xxx'`
- 导入：`require("path")`

**# 示例**

```js
// A.js
// 1
module.exports = { a: 10, b: 20 };

// 2
module.exports.a = 10;
module.exports.b = 20;

// 3
exports.a = 10;
exports.b = 20;

// app.js
const moduleA = require("./modules/A"); // { a:10, b:20 }
```

> 提示：
>
> 1. `exports` vs `module.exports` ：`exports` 是对 `module.exports` 的引用，不能直接给 `exports` 赋值，直接赋值无效，结果是一个空对象，`module.exports` 可以直接赋值。
> 2. 一个文件不能写多个 `module.exports` ，如果写多个，对外暴露的接口是最后一个 `module.exports`。
> 3. 模块如果没有指定使用 `module.exports` 或者 `exports`  对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象。

## 3. AMD

AMD（Asynchronous Module Definition，异步模块定义），因为 commonJS（同步加载） 规范不适用于浏览器，所以有了AMD规范，目前，主要有两个Javascript 库实现了AMD规范：

- [requirejs >>](https://requirejs.org/)
- [curl >>](https://github.com/cujojs/curl)

AMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

**# API**

- 定义模块：
  - 有依赖：`define(['module1', 'module2'], (m1, m2) => { return 模块; })`
  - 无依赖：`define(() => { return 模块 })`
- 引入：`require(['module1', 'module2'], (m1, m2) => { 使用m1, m2模块 })`

**# 示例**

```js
// A.js
define(function () {
  const splitBirth = (idCard) => {
    if (isNaN(idCard) || idCard.length !== 18) {
      return null;
    }
    return {
      year: idCard.slice(6, 10),
      month: idCard.slice(10, 12),
      day: idCard.slice(12, 14),
    };
  };
  return {
    splitBirth,
  };
});
```

```js
// B.js
define(["./A.js"], function (A) {
  const getBirth = (idCard) => {
    const obj = A.splitBirth(idCard);
    if(obj) {
      return `出生年月：${obj.year}年${obj.month}月${obj.day}日`;
    }
    return "";
  };
  return {
    getBirth
  }
});
```

```js
// main.js
require(["./utils/B.js"], (B) => {
  const birth = B.getBirth("510321199307161234");
  console.log(birth); // 出生年月：1993年07月16日
});
```

## 4. CMD

`require.js` 在申明依赖的模块时会在第一時間加载并执行模块内的代码（依赖前置）：

```js
define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) { 
    // 等于在最前面声明并初始化了要用到的所有模块
    if (false) {
      // 即便没用到某个模块 b，但 b 还是提前执行了
      b.foo()
    } 
});

```

CMD 是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在 `sea.js` 推广过程中产生的。

```js
/** AMD写法 **/
define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) { 
     // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
        // 即便没用到某个模块 b，但 b 还是提前执行了
        b.doSomething()
    } 
});

/** CMD写法 **/
define(function(require, exports, module) {
    var a = require('./a'); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});

/** sea.js **/
// 定义模块 math.js
define(function(require, exports, module) {
    var $ = require('jquery.js');
    var add = function(a,b){
        return a + b;
    }
    exports.add = add;
});
// 加载模块
seajs.use(['math.js'], function(math){
    var sum = math.add(1+2);
});

```

## 5. ES6 Module

ES6 在语言标准的层面上，实现了模块功能，而且非常简单，ES6到来，完全可以取代 CommonJS 和AMD规范，成为浏览器和服务器通用的模块解决方案。

**# API**

- [import](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)：导入模块
- [export](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)：导出模块

**# 示例**

> **导出单个属性**

```javascript
export const a = 10;
export const b = 20;

import {a, b} from "./xxx"
```

> **导出属性列表**

```javascript
const a = 10;
const b = 20;
export { a, b };

import {a, b} from "./xxx"
```

> **重命名导出**

```javascript
export { a as x, b as y }

import {x, y} from "./xxx"
```

> **默认导出**

```javascript
export default { min:10, max:20 }

import 变量 from "./xxx"
```

> **导入所有**

```javascript
import * as xx from './xxx'
```

## 6. UMD

严格上说，UMD 不能算是一种模块规范，因为它没有模块定义和调用，这是 `AMD` 和 `CommonJS`的结合体，保证模块可以被 AMD 和 CommonJS 调用。

# 三、总结

| #            | `IIFE`   | `CommonJS`         | `AMD`                                  | `CMD`                                           | `ES6`               |
| ------------ | -------- | ------------------ | -------------------------------------- | ----------------------------------------------- | ------------------- |
| **实现**     | 浏览器端 | 服务端             | 浏览器端                               | 浏览器端                                        | 浏览器端            |
| **加载方式** | 顺序加载 | 同步加载（运行时） | 异步加载（依赖前置）                   | 按需加载                                        | 编译时              |
| **库**       | /        | /                  | [requirejs >>](https://requirejs.org/) | [seajs >>](https://seajs.github.io/seajs/docs/) | /                   |
| **来源**     | 前端社区 | 前端社区           | 前端社区                               | 前端社区                                        | 官方                |
| **是否编译** | 否       | 否                 | 否                                     | 否                                              | 是                  |































