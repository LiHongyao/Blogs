# @工厂设计模式

```typescript
function createPerson(name, age, job) {
    return {
        name, age, job
    }
}
let per = createPerson("木子李", 30, "前端工程师");
console.log(per);
```

# @单例设计模式

单例即唯一实例，存在于整个应用程序生命周期，一般用于实现数据共享，建议在单页（SPA）开发中使用。

单例模式有 3 个特点：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点；

```js
let _single = null;// 缓存单例对象
function Single() {
    if (!_single) {
        _single = {};
    }
    return _single;
}

module.exports  = Single;
```

```js
class Single {
  // -- 通过构造函数创建单例
  constructor() {
    if (!Single.prototype.instance) {
      Single.prototype.instance = this;
    }
    return Single.prototype.instance;
  }

  // -- 通过类方法获取单例
  static getSingle() {
    if (!Single.prototype.instance) {
      return new Single();
    }
    return Single.prototype.instance;
  }

  sayHi() {
    console.log('Hello, Signle!');
  }
}

let s1 = Single.getSingle();
let s2 = Single.getSingle();
let s3 = new Single();
let s4 = new Single();


console.log(s1 === s2); // true
console.log(s3 === s4); // true
console.log(s1 === s3); // true

s1.sayHi();
s2.sayHi();
s3.sayHi();
s4.sayHi();
```

使用场景：

- 引用第三方库（多次引用只会使用一个库引用，如 jQuery）
- 弹窗（登录框，信息提升框）
- 购物车 (一个用户只有一个购物车)
- 全局态管理 store (Vuex / Redux)

# @观察者模式

观察者模式：定义了对象间一种一对多的依赖关系，当目标对象 `Subject` 的状态发生改变时，所有依赖它的对象 `Observer` 都会得到通知。

模式特征：

- 一个目标者对象 `Subject`，拥有方法：添加 / 删除 / 通知 Observer；

- 多个观察者对象 `Observer`，拥有方法：接收 Subject 状态变更通知并处理；

- 目标对象 `Subject`  状态变更时，通知所有 `Observer`。

Subject 添加一系列 Observer， Subject 负责维护与这些 Observer 之间的联系，“你对我有兴趣，我更新就会通知你”。

```js
// -- 被观察者
class Subject {
  constructor() {
    // -- 存储观察者
    this.observers = [];
  }
  add(observer) {
    this.observers.push(observer);
  }
  remove(observer) {
    const index = this.observers.findIndex(observer);
    index !== -1 && this.observers.splice(index, 1);
  }
  notify() {
    this.observers.forEach((o) => {
      o.update();
    });
  }
}

// -- 观察者
class Observer {
  constructor(name) {
    this.name = name;
  }
  update() {
    console.log(`${this.name}：updated!`);
  }
}

// --------- 示例 -----------
// -- 创建被观察者
const subject = new Subject();
// -- 创建观察者
const obs1 = new Observer('张三');
const obs2 = new Observer('李四');
// -- 添加观察者
subject.add(obs1);
subject.add(obs2);
// -- 触发通知
subject.notify();
```

优势：目标者与观察者，功能耦合度降低，专注自身功能逻辑；观察者被动接收更新，时间上解耦，实时接收目标者更新状态。

缺点：观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对事件通知进行细分管控，如 “筛选通知”，“指定主题事件通知” 。

# @发布订阅模式

发布订阅模式：基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。

发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。

```js
// -- 发布订阅中心
class PubSub {
  constructor() {
    // 1、记录发布的消息
    this.messages = {};
    // 2、存储订阅者
    this.listeners = {};
  }
  // @发布
  publish(type, content) {
    // 1、获取当前主题发布的消息集合
    const msg = this.messages[type];
    // 2、如果不存在，则初始化存储该主题消息的容器
    if (!msg) {
      this.messages[type] = [];
    }
    // 3、将最新发布的消息存入容器中
    this.messages[type].push(content);
  }
  // @订阅
  subscribe(type, cb) {
    // 1、获取当前主题所有的订阅者
    const listener = this.listeners[type];
    // 2、如果不存在，则初始化存储该主题订阅者的容器
    if (!listener) {
      this.listeners[type] = [];
    }
    // 3、将订阅者存入容器中
    this.listeners[type].push(cb);
  }
  // @通知
  notify(type) {
    // 1、获取当前主题下发布的消息
    const messages = this.messages[type];
    // 2、获取当前主题下的定于这
    const listeners = this.listeners[type];
    // 3、遍历订阅者并逐一推送消息
    if (messages && listeners) {
      listeners.forEach((cb, index) => cb(messages));
    }
  }
}

// -- 发布者
class Publisher {
  constructor(name, context) {
    // 1、标识符（可用于记录发布者名称）
    this.name = name;
    // 2、上下文（这里用于存储发布订阅者）
    this.context = context;
  }
  publish(type, content) {
    // 1、通过发布订阅者发布消息（type：主题；content：发布内容）
    this.context.publish(type, content);
  }
}
// -- 订阅者
class Subscriber {
  constructor(name, context) {
    // 1、标识符（可用于记录订阅者名称）
    this.name = name;
    // 2、上下文（这里用于存储发布订阅者）
    this.context = context;
  }
  subscribe(type, cb) {
    // 1、通过发布订阅者订阅（type：主题；cb：回调函数 -- 主要用于发布消息时回调）
    this.context.subscribe(type, cb);
  }
}

// --------- 示例 -----------
// -- 创建事件中心
const pubsub = new PubSub();

// -- 创建发布者
const publisherA = new Publisher('发布者1', pubsub);
publisherA.publish('主题1', '你好！');
publisherA.publish('主题1', '世界！');

// -- 创建订阅者
const subscriberA = new Subscriber('张三', pubsub);
subscriberA.subscribe('主题1', (res) => {
  console.log('张三收到消息：', res);
});

const subscriberB = new Subscriber('李四', pubsub);
subscriberB.subscribe('主题1', (res) => {
  console.log('李四收到消息：', res);
});

// -- 发送通知
pubsub.notify('主题1');
```

发布订阅模式中，订阅者各自实现不同的逻辑，且只接受自己对应的事件通知。实现你想要的 “不一样”。

发布订阅的通知顺序：

- 先订阅后发布时才通知（常规）
- 订阅后可获取过往以后的发布通知 （QQ离线消息，上线后获取之前的信息）

> **观察者模式 vs 发布订阅者模式**

从表面上看：

- 观察者模式有两个角色：观察者 + **被观察者**
- 发布订阅者模式有三个角色：发布者 + 订阅者 + **发布订阅中心**

往更深层次讲：

- 观察者和被观察者，是松耦合的关系；
- 发布者和订阅者，则完全解耦；

从使用层面上讲：

- 观察者模式，多用于单个应用内部；
- 发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件



















