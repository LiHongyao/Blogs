# 一、网络基础

HTTP（**Hyper Text Transfer Protocol**,  超文本传输协议）

## 1. 是什么？

1）HTTP是一种 **超文本传输协议**，用于完成从客户端到服务器端等一系列运作流程。

2）HTTP是一种 **应用层协议**，由请求和响应构成，是一个标准的客户端服务器模型。

3）HTTP是一种 **无状态协议**，同一个客户端的这次请求和上次请求没有任何关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie/session/websocket等来解决。

4）默认HTTP的端口号为**80**，HTTPS（更安全的http协议）的端口号为**443**。

**# 本质：**

HTTP就是一个通信规则，规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端发送给服务器的格式叫“请求协议”；服务器发送给客户端的格式叫“响应协议”。可以说，Web 是建立在 HTTP 协议上进行通信的。

## 2. 历史

> 为知识共享而规划 Web（摘自 *《图解 HTTP》*）

1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。

CERN（欧洲核子研究组织）的 **蒂姆 • 伯纳斯 - 李**（Tim Berners Lee）博士提出了一种能让远隔两地的研究者们共享知识的设想。

最初设想的基本理念是：借助多文档之间相互关联形成的超文本（Hyper Text），连成可相互参阅的 WWW（World Wide Web，万维网）。

现在已提出了 3 项 WWW 构建技术，分别是：

- **HTML**（Hyper Text Markup Language，超文本标记语言）；
- **HTTP**（Hyper Text Transfer Protocol，超文本传输协议） ；
- **URL**（Uniform Resource Locator，统一资源定位符）。

HTTP 0.9 在 1990 年问世。那时候的 HTTP 还没有作为正式的标准被建立。

HTTP 1.0 在 1996 年 5 月 正式作为标准。该协议标准现在仍然被广泛使用在服务器端。

HTTP 1.1 在 1997 年 1 月公布为当前主流的 HTTP 协议版本。

HTTP 2.0 在 2012 年 3 月 征集建议。

HTTP 2.0 在 同年的 9 月份 发布了第一个草案。

HTTP 2.0 在 2014 年 11 月实现了标准化。

## 3. 网络基础TCP/IP

理解 HTTP 之前，我们先简单的来了解一下 TCP/IP 协议族。一般使用的网络都是在 TCP/IP 协议的基础上运作的，而 HTTP 属于它内部的一个子集。

### 3.1. TCP/IP 协议族

在计算机和网络设备进行互相通信时，双方都必须基于相同的方法。比如，如何探测到通信目标，是哪边先发起通信、用什么语言进行通信、怎样结束通信等等一些规则都是先要确定好的。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而这种规则称为 **协议**（protocol）。

协议中包括：从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示要处理的步骤，等等。将这些相关联的协议集合起来总称为 TCP/IP。

### 3.2. TCP/IP 模型各层作用

TCP/IP 重要的点就是分层。有以下`4`层：**应用层（HTTP / FTP / DNS）、传输层（TCP / UDP）、网络层（IP）和数据链路层（链接网络的硬件部分）**。

下面来介绍各层的作用。keyi 

- **应用层**：应用层决定了向用户提供应用服务时通信的活动。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统），HTTP 协议也在该层。
- **传输层**：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传送。该层有两个不同的协议：TCP（Transmission Control Protocol） 传输控制协议和 UDP（User Data Protocol） 用户数据协议。
- **网络层**：网络层用来处理在网络上的数据包。数据包是网络传输的最小数据单位。网络层的作用就是在多条路线中选出一条传输路线进行数据传输。
- **链路层**：用来处理连接网络的硬件部分。包括什么操作系统、NIC（Network Interface Card，网络适配器，即网卡）、硬件的设备驱动、什么路由器啊之类的物理可见部分，都属于该层。

TCP/IP 层次化的好处是：如果互联网由一个协议统一规划，某个地方需要改变设计时，就必须将所有部分整体替换掉。而分层之后只需要把变动的层替换掉。把各层之间的接口部分规划好之后，每层内部的设计就可以自由改动。比如，处于应用层上的应用可以只考虑分配给自己的任务，不用去考虑其他的问题。

### 3.3. TCP/IP 通信传输流

TCP/IP 协议进行通信时，会通过分层顺序和对方进行通信。客户端从应用层往下走，服务器端则从链路层往上走。看下面的图。

![](./IMGS/http-trans.jpg)

我们用 HTTP 举例来说明：

1）客户端在应用层发出一个 HTTP 请求。

2）接着，在传输层接收到应用层的数据后进行分割，给每个报文打上标记序号以及端口号转发给网络层。

3）在网络层，添加通信目的地的 MAC 地址后转发给链路层。

4）接收端（也叫服务器端）的服务器在链路层接收到数据，按次序向上层发送，一直到应用层。传输到应用层才算真正接收到客户端发过来的 HTTP 请求。

**# Http协议在TCP/IP协议栈中的位置**

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：

![](IMGS/http_tcp_ip.jpg)

**# Http 请求响应模型**

HTTP协议永远都是客户端发起请求，服务器响应。见下图：

![](IMGS/http_model.jpg)

这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。

**# Http 特点**

- **无状态协议**：就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。
- **应用层协议**：由请求和响应构成，是一个标准的客户端服务器模型
- **多次HTTP请求**：在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。
- **基于TCP**：HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。

**# Http 工作流程**

**1. 服务器 < -- > 客户端**

一次HTTP操作称为一个事务，其工作过程可分为四步：

1. 首先客户端与服务器需要 `建立连接` 。只要单击某个超链接，HTTP的工作就开始啦。


2. 建立连接后，客户端发送一个 `请求` 给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容。


3. 服务器接到请求后，给予相应的 `响应` 信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户端与服务器`断开连接`。

> 建立连接 -> 客户端发送请求 -> 服务器响应请求 -> 渲染 -> 断开连接

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

**2. 服务器 < -- > 代理 < -- > 客户端**

我们的请求有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示：

![](./IMGS/http_delete.png)

**3. 代理服务器的作用**

代理服务器就是网络信息的中转站，有什么功能呢？

1. 提高访问速度， 大多数的代理服务器都有缓存功能。
2. 突破限制， 也就是FQ（翻墙）了。
3. 隐藏身份。
4. 过滤（像反病毒扫描，家长控制）
5. 负载均衡（让多个服务器服务不同的请求）
6. 认证（对不同资源进行权限管理）
7. 日志记录（允许存储历史信息）

## 4. 和HTTP相关的协议

在HTTP客户端向服务器端发送报文之前，需要用到 **IP、TCP、DNS** 这三个和 HTTP 密不可分的协议。

### 4.1. 负责传输的 IP 协议

IP（`Internet Protocol`）网络协议处于**网络层**。IP协议的作用是把各种数据包传送给对方。但要保证正确的传送给对方，其中两个重要的条件是 <u>IP 地址</u> 和 <u>MAC 地址</u>。可以把它想象成你家的地址，或者说你的电话号码。

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。

> 提示：IP 和 IP地址别搞混了，IP是一种协议。而IP地址是则是每台计算机的标识。

**ARP 协议**

IP 间的通信依赖 MAC 地址。在网络上通信的双方很少会在同一个局域网，一般都是经过多台计算机或者网络设备中转才能连接到对方。而在中转的过程中，会利用下一站中转设备的 MAC 地址进行搜索下一个中转目标。而这时，会用到 <u>ARP协议</u>。ARP协议是一种用来解析地址的协议，根据通信方的 IP 地址就能反查出对应的 MAC 地址。

在到达通信目标前的中转过程中，计算机和路由器只能获取粗略的传输路线，这种机制叫做<u>路由选择</u>。

就跟你在淘宝上买东西是一样的道理。比如，你在淘宝网买了件衣服，快递公司会根据你的地址进行送货，在送货这个过程中，并不是直接送到你手里。而是经过各种什么杭州中转站然后又到深圳中转站，之后才送到你手里。

![](./IMGS/http_arp.png)

### 4.2. 确保可靠性的 TCP 协议

TCP 协议处于传输层，主要的作用是 **提供可靠的字节流服务**。字节流服务指的是，为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理。而可靠性的传输服务指的是，能够把数据准确可靠的传给对方。

为了准确的将数据传送给对方，三次握手就出现了。下图展示这个过程。

握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）

![](./IMGS/http_tcp.png)



1. 第一次握手：客户端先发送一个带 SYN 标志的数据包给对方。
2. 第二次握手：服务器端收到之后，回传一个带有 SYN/ACK 标志的数据包表示传达确认信息。
3. 第三次握手：最后，客户端再传回一个带 ACK 标志的数据包，表示 “握手” 结束。

> 提示：若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

### 4.3. 负责域名解析的 DNS 服务

DNS 服务和 HTTP协议一样，处于应用层。它主要的作用是，将域名解析成 IP 地址。DNS 协议可以通过域名查找 IP 地址，也可以通过 IP 地址反查域名的服务。

![](./IMGS/http_dns.png)

下面展示每个协议和HTTP协议的关系。

![](./IMGS/http_relations.png)

## 5. URL & URI

- URL（Uniform Resource Locator，统一资源定位符），是访问Web网站需要输入的网站地址。例如，`http://www.lihy.com`。
- URI（Uniform Resource Identifier，统一资源标识符），它的作用是区分互联网中的不同资源。比如，HTML 文档、图像、视频片段、程序等等。

URI 用字符串标识某一互联网资源；

URL表示资源的地点（互联网上所处的位置）；

URL是 URI 的子集；

### 5.1. URI格式

URI 地址用于描述一个网络上的资源，基本格式如下：

```
schema://usr:pass@host[:port]/path/.../[?query-string][#anchor]
```

- schema：协议（例如：http, https, ftp等）
- usr:pass@：登录信息（不推荐使用，因为不安全）
- host：服务器地址，有三种格式：
  - 以域名的形式 `www.baidu.com`
  - 以IPv4的地址名 `192.168.0.1`
  - 以`[0:0:0:0:0:0:1]`这种方括号括起来的 IPv6 地址;
- port：端口号，默认为80
- path：资源路径（文件路径）
- query-string：发送给Http服务器的数据（查询字符串）
- anchor：锚

### 5.2. 示例

```js
"http://127.0.0.1:8081/weather?city=chengdu&date=2019-10-01#stuff"
```

- schema：http
- host：127.0.0.1
- port：8081
- path：/weather
- query-string：city=chengdu&date=2019-10-01
- anchor：stuff

# 二、HTTP 基础

## 1. HTTP 请求响应模型

![](./IMGS/http_model.png)

HTTP协议用于客户端和服务器端之间的通信。在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。

请求必定由客户端发出，而服务器端回复响应。

## 2. HTTP  协议是无状态的

HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

![](./IMGS/http_stateless.png)



使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了
更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。

可是，随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。

HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 **Cookie** 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。有关 Cookie 详细内容稍后讲解。

## 3. 请求 URI 定位资源

HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。

## 4. 请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

- GET：获取资源。
- POST：传输数据给服务器。
- PUT：传输文件（自身不带验证机制，任何人都可以上传文件 , 存在安全性问题）。
- HEAD：和 GET 方法一样。但是只返回响应头部。作用是确定 URL 的有效性和资源更新的时间。
- DELETE：删除指定的资源（与PUT相反，但是同样自身不带验证机制，所以一般也不用）。
- OPTIONS：询问支持的方法
- TRACE：用来确认连接过程中发生的一些操作。
- CONNECT：要求用隧道协议连接代理。CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

## 5. 持久连接节省通信量

HTTP 协议是一种无状态的协议，对发送过的请求/响应都不做持久化处理。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使
这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。

比如，使用浏览器浏览一个包含多张图片的 HTML页面时，在发送请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。

![](./IMGS/http_tcp_stateless.png)



**持久链接**

为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。它的特点是，不管是客户端还是服务器端，只要其中的一端没有提出断开连接，那么就会保持 TCP 连接状态。

![](./IMGS/http_close_tcp.png)



其好处是，减少 TCP 连接的重复建立和断开连接造成的额外开销，减轻服务器压力。这样使得 HTTP 请求和响应速度更快结束，也提高页面的显示速度。

在HTTP 1.1 中的所有连接都是默认开启的（`keep-alive`）。通过请求/响应头部的`Connection` 字段可以查看是否开启持久化连接，而在 HTTP1.0中是默认关闭的（`close`）。

**管线话**

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求，也就是并行处理。所以，管线化比持久化连接还要更快。

![](./IMGS/http_pipelining.png)



## 6. 使用 Cookie 的状态管理

HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。

不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。

![](./IMGS/http_cookie_1.png)

图：如果让服务器管理全部客户端状态则会成为负担。

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

- 没有 Cookie 信息状态下的请求

  ![](./IMGS/http_cookie_2.png)

- 第 2 次以后（存有 Cookie 信息状态）的请求

  ![](./IMGS/http_cookie_3.png)

上图展示了发生 Cookie 交互的情景，HTTP 请求报文和响应报文的内容如下。

1. 请求报文（没有 Cookie 信息的状态）

   ```http
   GET /reader/ HTTP/1.1
   Host: hackr.jp
   *首部字段内没有Cookie的相关信息
   ```

2. 响应报文（服务器端生成 Cookie 信息）

   ```http
   HTTP/1.1 200 OK
   Date: Thu, 12 Jul 2012 07:12:20 GMT
   Server: Apache
   ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
   Content-Type: text/plain; charset=UTF-8
   ```

3. 请求报文（自动发送保存着的 Cookie 信息）

   ```http
   GET /image/ HTTP/1.1
   Host: hackr.jp
   Cookie: sid=1342077140226724
   ```

# 三、HTTP 报文

HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。本章就让我们来了解一下请求和响应是怎样运作的。

## 1. HTTP 报文

用于 HTTP 协议 <u>交互的信息</u> 被称为 HTTP 报文。

请求端（客户端）的HTTP 报文叫做 <u>请求报文</u>；

响应端（服务器端）的HTTP 报文叫做 <u>响应报文</u>。

HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为 <u>报文首部</u> 和 <u>报文主体</u> 两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

![](./IMGS/http_message.png)



## 2. 请求报文 & 响应报文结构

![](./IMGS/http_message_struct.png)



- **起始行** 有以下两种类型。

  - 请求行：请求的方法、请求的 URL、HTTP的版本

  - 响应行：HTTP 版本、状态码

- **首部字段**（`header`）：一些头部信息，以 `key: value` 的形式。

- **空行（CR + LF）**

- **报文主体**（`body`）：发送 & 响应的数据。

## 3. 请求报文 & 响应报文实例

### 3.1. 请求报文

客户端发向服务端，请求报文的格式如下：

```markdown
# GET
GET http://localhost:3000/api/user HTTP/1.1
Content-Type: application/json

# POST
POST http://localhost:3000/api/user/login HTTP/1.1
Content-Type: application/json

{
    "username":"lihy",
    "password":"456"
}
```

### 3.2. 响应报文

服务端发向客户端，响应报文格式如下：

```js
HTTP/1.1 200 OK
Vary: Origin
Access-Control-Allow-Origin: *
Content-Type: application/json; charset=utf-8
Content-Length: 325
Date: Mon, 17 Feb 2020 01:50:30 GMT
Connection: keep-alive

{
  "message": "查询成功",
  "users": [
    {
      "gender": "保密",
      "_id": "5e45880cdc0d6b4bec985505",
      "username": "lihy",
      "password": "456",
      "__v": 0
    }
  ]
}
```

## 4. 编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。

- 内容编码
  - gzip（GNU zip）
  - compress（UNIX 系统的标准压缩）
  - deflate（zlib）
  - identity（不进行编码）
- 分块传输编码

## 5. 发送多种数据的多部分对象集合

![](./IMGS/http_multipart.png)



发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。

相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

多部分对象集合包含的对象如下。

- **multipart/form-data**：在 Web 表单文件上传时使用。
- **multipart/byteranges**：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。

## 6. 获取部分内容的范围请求

以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。

要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。

对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。

![](./IMGS/http_range.png)



执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。byte 范围的指定形式如下。

- **5001 ~ 10 000** 字节：

  ```http
  Range: bytes=5001-10000
  ```

- 从 **5001** 字节之后全部的：

  ```http
  Range: bytes=5001-
  ```

- 从一开始到 **3000** 字节 和 **5000~7000** 字节的多重范围：

  ```http
  Range: bytes=-3000, 5000-7000
  ```

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。

如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。

## 7. 内容协商返回最合适的内容

同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。

当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。

![](./IMGS/http_content_negotiation.png)

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

包含在请求报文中的某些首部字段（如下）就是判断的基准。

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下 3 种类型：

1）服务器驱动协商（Server-driven Negotiation）

由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。



2）客户端驱动协商（Agent-driven Negotiation）

由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。



3）透明协商（Transparent Negotiation）

是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 四、状态码

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

![](./IMGS/http_status.png)

数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5种。

| #    | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1xx  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2xx  | Success（成功状态码）            | 请求正常处理完毕           |
| 3xx  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4xx  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5xx  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## 1. 1xx

- `1XX` 表示接收的请求正在处理。

## 2. 2xx 成功

- `200 OK`：表示客户端发送的请求在服务器端被正常处理了。
- `204 No Content`：表示请求被处理成功，但没有资源可返回。
- `206 Partial Content`：表示客户端只获取文件的一部分内容，而服务器成功执行了这部分的`GET`请求。响应报文中含 `Content-Range` 指定部分的实体内容。

## 3. 3xx 重定向

- `301 Moved Permanenty`：永久重定向。表示请求的资源已经被分配了新的 URI，以后就使用资源现在所指的 URI。

- `302 Found`：临时重定向。表示请求的资源被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

  > 提示：和 **301 Moved Permanently** 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。

- `303 See Other`：该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。

  > 提示：
  >
  > 1）303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。
  >
  > 2）比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303状态码是最理想的

- `304 Not Modified`：表示请求已经找到，但不符合条件请求。协商缓存就会返回这个状态码。

- `307 Temporary Redirect`：临时重定向，和`302`类似。但是不能改变请求方法。

  > 提示：尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

## 4. 4xx 客户端错误

- `400 Bad Request`：表示请求报文中存在语法错误。
- `401 Unauthorized`：表示发送的请求要通过 HTTP 认证的认证消息。如果之前请求过一次，就表示用户认证失败。
- `403 Forbidden`：表示对请求资源的访问被服务器拒绝。
- `404 Not Found`：表示服务器上无法找到请求的资源。

## 5. 5xx 服务器错误

- `500 Internal Serve Error`：表示服务器端在执行请求时发生错误。
- `503 Service Unavailable`：表示服务器暂处于超负荷或者正在进行停机维护。

状态码参考地址：\<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\>

# 五、与 HTTP 协作的 Web 服务器

HTTP进行通信时，除了客户端和服务器端这两个之外，还有一些用于通信数据转发的应用程序。例如 **代理、网关、隧道和缓存**。

### 5.1. 代理

代理是一种具有**转发**功能的应用程序，它存在于客户端和服务器端之间，相当于一个中间人。它将客户端发送过来的请求并转发给服务器端。当然，它也会将服务器端返回的响应转发给客户端。

![](./IMGS/http_proxy.PNG)

每次通过代理服务器转发请求或响应时，头部都会出现 `Via` （标记出经过的主机信息）这个字段。

使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。

代理有多种使用方法，按两种基准分类。一种是<u>是否使用缓存</u>，另一种是是否会修改报文。

- **缓存代理**

  代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

- **透明代理**

  转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。

### 5.2. 网关

网关是一种特殊的服务器，作为其他服务器的中间实体使用。用于**将 HTTP 请求转化成其他协议通信**。网关接收请求时就好像自己的资源的源服务器一样对请求做处理。

![](./IMGS/http_gateway.png)

### 5.3. 隧道

隧道是可按要求建立一条和其他服务器的通信线路，到时候使用 **SSL 加密** 进行通信。隧道的目的是保证客户端和服务器进行安全的通信。

![](./IMGS/http_tunnel.png)

### 5.4. 缓存

缓存是指代理服务器或客户端本地磁盘中保存的资源副本。利用缓存可以减少向源服务器的访问，主要目的是 <u>减少网络带宽的流量和通信时间</u>。

缓存服务器是代理服务器的一种，当代理转发从服务器返回的响应时，会保存一份资源的副本。缓存服务器的优点在于通过缓存可以避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求。

![](./IMGS/http_cache.png)

**缓存的有效期**

每当源服务器上的资源更新时，如果还是用不变的缓存，那就会变成返回更新前的旧资源。

即使存在缓存，也会因为客户端的要求、缓存的有效期等等一些因素，向源服务器确认资源的有效性。如果缓存的资源已过期，缓存服务器会向源服务器上获取新的资源。

**客户端缓存**

这里的客户端缓存指的是浏览器中的缓存。浏览器缓存如果未过期，就不用向源服务器请求相同的资源，直接获取缓存在本地磁盘中的资源。当资源过期时，会向源服务器确认资源的有效性。如果缓存的资源过期，就会再次向源服务器发起资源请求。

# 六、HTTP 首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部。

## 1. 首部字段类型

- 通用首部字段（**General Header Fields**）

  请求报文和响应报文两方都会使用的首部。

- 请求首部字段（**Request Header Fields**）

  从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

- 响应首部字段（**Response Header Fields**）

  从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

- 实体首部字段（**Entity Header Fields**）

  针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

## 2. HTTP/1.1 首部字段一览

> HTTP/1.1 规范定义了如下 47 种首部字段。

> 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

> 请求首部字段

| 首部字段名          | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记（与 If-Match 相反）              |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
| If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中 URI 的原始获取方                     |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP 客户端程序的信息                         |

> 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

> 实体首部字段

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源可支持的HTTP方法         |
| Content-Encoding | 实体主体适用的编码方式       |
| Content-Language | 实体主体的自然语言           |
| Content-Length   | 实体主体的大小（单位：字节） |
| Content-Location | 替代对应资源的URI            |
| Content-MD5      | 实体主体的报文摘要           |
| Content-Range    | 实体主体的位置范围           |
| Content-Type     | 实体主体的媒体类型           |
| Expires          | 实体主体过期的日期时间       |
| Last-Modified    | 资源的最后修改日期时间       |

## 3. 非 HTTP/1.1 首部字段

在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。

## 4. End-to-end & Hop-by-hop

HTTP 头字段定义成缓存代理和非缓存代理。分为两种类型。

- **端到端头部`End-to-end`**
  分在这个类别中的头部会转发给请求或响应对应的最终接收目标，而且必须保存在缓存生成的响应中，另外规定它必须被转发。
- **逐跳头部`Hop-by-hop`**
  分在这个类别中的头部只对单次转发有效，会因通过缓存或代理而不转发。在 HTTP 1.1 和之后的版本中，如果使用`Hop-by-hop`头，就要提供 `Connection` 头字段。

除了下面 8 个头字段外，其他所有字段都属于端到端头部。

- `Connection`
- `Keep-Alive`
- `Proxy-Authenticate`
- `Proxy-Authorization`
- `Trailer`
- `TE`
- `Transfer-Encoding`
- `Upgrade`

# 七、确保 Web 安全的HTTPS

在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。

## 1. HTTP 缺点

HTTP协议主要的不足之处有以下几点。

- 通信使用明文，内容会被窃听
- 不验证通信方的身份，可能遭遇伪装
- 无法证明报文的完整性，可能已遭到篡改

**@1. 通信使用明文，内容会被窃听**

HTTP 协议本身没有加密功能，所以无法做到对通信请求和响应内容进行加密。

**TCP/IP 是会被窃听的网络**

由于 TCP/IP 协议的工作机制，通信内容在所有通信线路上都有可能遭到窥视。不管是哪个角落的服务器在跟客户端进行通信，通信的线路上的一些设备都不可能是个人物品。所以不排除在某个环节上遭到恶意窥视的行为。即使进行加密处理，也会被窥视到通信的内容。窃听相同端上的通信并不是难事，只要收集在网络上流动的数据包就行。可以通过抓包和嗅探器工具来收集数据包。

**解决方案：【加密处理防止窃听】**

最常见的两种加密方式是通信加密和内容加密。

- 通信加密：HTTP 协议中本身没有加密机制，但可以通过 **SSL（Secure Socket Layer 安全套阶层）** 或**TLS（Transport Layer Security 安全传输层协议）** 的组合使用，加密HTTP的通信内容。用 SSL 建立安全通信线路后，就可以在这条线路上进行 HTTP 通信。和 SSL 组合使用的 HTTP 叫做 **HTTPS （HTTP Secure 超文本传输安全协议）** 或 HTTP over SSL。
- 内容加密：由于 HTTP 协议中没有加密机制，那么可以对传输的内容本身进行加密。也就是把 HTTP 报文中包含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文主体(`body`)进行加密处理后再发送请求。要做到内容的加密，前提是客户端和服务器端同时具有加密和解密的机制。主要应用在 Web 服务器中。该方式不同于 SSL 和 TLS 把整个通信线路加密处理，所以内容还是会有被篡改的可能。



**@2. 不验证通信方的身份，可能遭遇伪装**

HTTP 协议的请求和响应都不会对通信方进行确认。

**任何人都可以发起请求**

在 HTTP 协议通信时，由于不存在确定通信方的处理步骤，任何人都可以发起请求。服务器只要收到请求，不管是谁都会返回一个响应（仅限发送端的 IP 地址和端口号没被 Web 服务器设置限制访问的前提下）。也就是来者不拒。

- 有可能是伪装的服务器。
- 有可能是伪装的客户端。
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存有重要的信息，只想发给特定用户通信的权限。
- 无法判断请求是从哪来、出自谁手。
- 即使是无意义的请求也照样接收。无法阻止大量请求下的 Dos 攻击（Denial of Service，拒绝服务器攻击）。

**解决方案：【查明对方的证书】**

虽然使用 HTTP 协议无法确定通信方，但使用 SSL 可以。SSL 除了加密处理外，还用了一种证书的手段，用于确认通信方。证书是由值得信任的第三方机构颁发，用来证明服务器和客户端是真实存在的。

通过证书，以证明通信方就是意料中的服务器，对个人来说，减少了个人信息泄露的危险。另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。



**@3.无法证明报文完整性，可能已篡改**

**收到的内容不完整**

没有任何办法确认，发出去的请求或响应和接收到的请求或响应是前后相同的。有可能在中途被篡改成其他的内容，即使内容是真的被改了，接收方也不会知道。

**解决方案：【MD5 和 SHA-1】**

可以使用 MD5 和 SHA-1 等散列值校验方法，以及用来确认文件的数字签名方法(PGP签名)对内容进行加密。但是用这些方法也无法保证正确，因为 MD5 和 PGP 本身被修改的话，用户也不会知道。

## 2. HTTPS

HTTP加上加密处理和认证以及完整性保护机制就是HTTPS。

**@1. HTTPS 是身披 SSL 外壳的 HTTP**

HTTPS 不是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。之前是 HTTP 和 TCP 进行通信，用了 SSL 之后，就变成了 HTTP 先和 SSL 通信，之后 SSL 和 TCP 通信。

- HTTP   # HTTP -> TCP -> IP

- HTTPS # HTTP -> SSL -> TCP -> IP

使用 SSL 之后，HTTP 就有了 HTTPS 的加密、证书和完整保护性这些功能。

### 1. 加密方式

SSL 用的是公开密钥加密的处理方式。加密方法中的加密算法是公开的，密钥则是保密的。通过这种方式可以保持加密方法的安全性。

加密和解密都会用到密钥。没有密钥就没办法对密码解密，任何人只要有密钥就可以进行解密，如果密钥被攻击者获得，那么加密也就没有意义了。

#### 1.1. 对称加密

加密和解密同用一个密钥的方式叫做共享密钥加密，也称为对称密钥加密。也就是说，客户端和服务器端共用一个密钥对消息进行加密。客户端在发送请求时，会用密钥对消息加密。服务器收到后，再用密钥对消息进行解密。

**缺点：**

对称加密虽然保证了消息保密性，但客户端和服务器端用的都是同一个密钥，如果说在传输的过程中出现了中间人或攻击者。密钥就有可能落到攻击者手中，这样就对消息加密就没有什么意义了。

#### 1.2. 非对称加密

非对称加密解决了对称加密的缺点。非对称加密用的是一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私有密钥只能是自己所拥有，而公开密钥则是任何人都可以拿到。

当客户端发送消息前，使用公共密钥进行加密，而服务器收到消息后，使用私有密钥进行解密。

**缺点：**

非对称加密需要在发送端在发送消息时，用公钥加密。但公钥是任何人都可以拿到，中间人也可以。中间人虽然不知道接收方的私钥是什么，但可以截获发送端的公钥，自己另外生成一把公钥或者篡改公钥，把公钥发给接收端。而且非对称加密处理起来比对称加密的方式更加复杂，这样就导致了效率变低。

#### 1.3. 混合加密机制

HTTPS 用的就是对称加密和非对称加密两者的混合加密。使用对称加密的好处是解密效率快，使用非对称加密的好处是在传输消息的过程中不会被破解。即使截获了数据，没有对应的私钥，也无法对消息进行破解。

#### 1.4. 摘要算法

数字摘要是采用 Hash 函数将需要加密的明文 “摘要” 成一串固定长度（`128`位）的密文，这串密文又称为数字指纹，它有固定长度，而且不同的明文摘要成密文，其结果总是不同，而同样的明文摘要必须一致。数字摘要是 HTTPS 能确保数据完整性和防篡改的根本原因。

#### 1.5. 数字签名

数字签名是非对称加密和数字摘要两项技术的应用，它将摘要信息用发送者的私钥加密，和原文一起发给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 Hash 函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果一样，那就说明收到的信息是完整的。否则说明信息被修改过，因此数字签名能够验证信息的完整性。

### 2. HTTPS 的工作流程

1. 首先是客户端向服务器端发起一个 HTTPS 请求。
2. 服务器端返回公钥证书给客户端。
3. 客户端收到公钥证书后，用证书的公钥验证数字签名，以确认服务器的公钥的真实性。
4. 客户端用随机数生成器生成临时的会话密钥，然后用服务器的公钥对该会话密钥进行加密，发送给服务器端。
5. 服务器收到后，用自己的密钥对会话密钥解密。
6. 之后客户端和服务器端就开始了 HTTPS 通信。

### 3. SSL 和 TSL

HTTPS 用的是 SSL（Secure Socket Layer 安全套阶层） 和 TLS（Transport Layer Security 安全传输层协议）这两个协议。SSL 最开始是网景先倡导，后来网景凉了，就转移给了 IETF 的手里。IETF 以 SSL 3.0 为准，之后又定制了 TLS1.0、TLS1.1和 TLS1.2。TLS 是以 SSL 为原型开发的协议。有时候统一称该协议为 SSL。

### 4. 为什么不一直用 HTTPS

凡事都具有两面性，不是说 HTTPS 安全就没有问题了。其实它还是存在一些问题的。在使用 SSL 时，它的处理速度会变慢。其原因有两种，一是通信慢，二是每次都进行加密通信，就导致消耗大量的 CPU 和内存资源，导致处理速度变慢。

- 除了和 TCP 连接、发送请求和响应之外，还要和 SSL 进行通信。
- 另外 SSL 要进行加密处理，在服务器和客户端都要进行加密和解密的运算处理。
- 要用 HTTPS 通信，购买证书是必不可少的。

当然可以用 SSL 加速（专用服务器）硬件来改善效率的问题。可以提高 SSL 的计算速度，分担负载。但只有在 SSL 处理时才发挥 SSL 加速器的效果。像一些非敏感的信息就用 HTTP 进行通信，对于敏感信息采用 HTTPS 通信，以节约资源。

### 5. HTTP 和 HTTPS 的区别

1. HTTP 是以明文的方式进行传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
2. HTTP 和 HTTPS 用的是两种不同的方式进行连接，端口号也不一样。前者是 `80`，后者是`443`。
3. 想要用 HTTPS 就得购买证书（CA），而免费的证书一般都很少，所以需要支付一定的费用。
4. HTTPS 对搜索引擎更友好，有利于 SEO ，优先索引 HTTPS 的网页。
5. HTTP 的连接简单，并且是无状态的。HTTPS 是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 要安全。

# 八、解决 HTTP 1.x 瓶颈的 SPDY

## 1. HTTP 1.x的缺点

HTTP 1.x主要有以下几个缺点：

1. HTTP 1.0 只允许在一个 TCP 连接上发送一个请求，HTTP 1.1中默认允许多个 TCP 连接。但是同一个 TCP 连接中，所有的数据通信都是按次序进行的，服务器一般是处理完一个响应之后，再继续处理下一个。这就造成了队首阻塞问题。
2. 请求只能从客户端开始，客户端不可以接收除了响应之外的指令。
3. 请求/响应头部不进行压缩就发送。头部信息越多延迟就越大。
4. 发送冗长的头部，每次互相发送相同的头部导致资源浪费。
5. 可随意选择数据压缩格式，非强制压缩发送。

## 2. SPDY

SPDY 是由谷歌开发的基于 TCP 协议的应用层协议。目标是为了优化 HTTP 协议的性能，通过压缩、多路复用和优先级技术，缩短网页的加载时间并提高安全性。SPDY 协议的核心思想是尽量减少 TCP 的连接数。SPDY 并不是一种代替 HTTP 的协议，而是对 HTTP 协议的增强。

SPDY 没有改写 HTTP 协议，而是在 TCP/IP的应用层和传输层之间通过新加会话层的形式运作。同时，考虑到安全问题，SPDY 规定通信中使用 SSL。

```
HTTP(应用层) -> SPDY(会话层) -> SSL(表示层) -> TCP(传输层)
```

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信。因此，可以照常使用 HTTP 的请求方法、Cookie 以及 HTTP 报文等等。

# 十、HTTP2.0

HTTP 2.0 可以说是 SPDY 的升级版（其实是基于 SPDY 设计的），但HTTP 2.0和 SPDY 还是存在一些不同的。主要有以下两点：

1. HTTP 2.0 支持明文传输，而 SPDY 强制使用 HTTP。
2. HTTP 2.0 消息头的压缩算法用的是 HPACK，而 SPDY 用的是 DEFLATE。

下面就简单的介绍一下 HTTP 2.0 新增的功能。由于HTTP 2.0 设计到的东西太多了，这里只列出部分。

- **二进制分帧层**：HTTP 2.0 性能增强的核心就是新增的二进制分帧层，HTTP 1.x是以换行符作为纯文本的分隔符，而 HTTP 2.0 把所有传输的信息分割成更小的**消息**和**帧**，并对它们采用二进制的格式编码。
- **多向请求和响应**：HTTP 2.0 中心的二进制分帧层，将 HTTP 消息分解成独立的帧，交错发送。然后在另一个端根据流标识符和头部把它们重新组装。解决了 HTTP 1.x的队首阻塞问题。
- **请求优先级**：把 HTTP 消息分解成多个独立的帧后，就可以通过优化这些帧的交错和传输顺序进一步性能优化。
- **服务器推送**：服务器可以对一个客户端请求发送多个响应。服务器还可以向客户端推送资源而且无需客户端明确的请求。
- **头部压缩**：在 HTTP 2.0 中，使用了 HPACK（HTTP2头部压缩算法）压缩格式对传输的头部进行编码，减少了头部的大小。并在两端维护了索引表，用于记录出现过的头部，之后在传输过程中就可以传输已经记录过的头部健名，对端收到数据后就可以通过键名找到对应的值。

如果想要了解更多 HTTP2.0 的知识可以看看《Web性能权威指南》这本书，里面讲得挺详细的。

# 十一、抓包工具

## 1. Fiddler

Fiddler是位于客户端和服务器端之间的代理，也是目前最常用的抓包工具之一 。它能够记录客户端和服务器之间的所有 请求，可以针对特定的请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。

点击前往下载页：https://www.telerik.com/download/fiddler

![](./IMGS/fiddler_install_01.png)

## 2. Charles

[官方下载 >>](https://www.charlesproxy.com/download/)

[破解版下载 >>](https://pan.baidu.com/s/1Hdm84v9iWDLswMgC0lSAIg)   提取码：h67l

# 十二、延伸（补充）知识

**\1. 浏览器输入地址到页面加载过程中发生了什么？**

```markdown
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器接收请求并响应
5. 浏览器解析并进行渲染
6. 连接结束
```

**\2. 如何DNS解析？** 

```markdown
将用户输入的地址解析成服务器所在的ip地址，DNS解析是一个递归查询的过程，这个过程所需要的步骤比较繁琐，并且存在着多次TCP和UDP（无连接传输协议）请求，十分占用资源。
# DNS优化：
1. DNS缓存：
一般可分为：浏览器缓存、系统缓存、路由器缓存、IPS缓存、跟域名缓存、顶级域名缓存和主域名服务器缓存
2. DNS负载均衡：
我们平常使用的CDN内容分发网络，使用到的就是DNS负载均衡技术。这个过程中使用多台服务器来提供响应，它的原理是当接收到用户发送过来的请求时，可以返回一个最适合用户的IP地址给用户（根据用户的地理位置或其他影响传输效率的因素分配的），这个过程就是DNS负载均衡，也叫做DNS重定向。
```

**\3. TCP如何保证消息的有序和不丢包？**

```markdown
1. SYN「sequence number」：包的序号，用来解决网络包乱序问题。
2. ACK「acknowledge number」：用于确认收到，用来解决不丢包的问题。
```

**\4. 如何理解TCP连接（三次握手）？**

![](./IMGS/tcp-handshake.png)

```markdown
TCP连接主要通过以下三次握手实现：

1. 第一次握手：客户端发送syn包到服务器，等待服务器确认接收。
2. 第二次握手：服务器确认接收syn包并确认客户的syn包，并发送回来一个syn+ack的包给客户端。
3. 第三次握手：客户端确认接收服务器的syn+ack包，并向服务器发送确认包ack

当三次握手完成后便TCP连接便完成了，客户端可以与服务器进行传输数据。四次握手就是中间多了一层等待服务器再一次响应回复相关数据的过程。
```

**\5. 为什么建立http建立连接需要三次握手？**

```
三次是最少的安全次数，两次不安全，四次浪费资源；
```

**\6. TCP关闭连接的过程（四次挥手）？**

![](./IMGS/tcp-wave.png)

```markdown
1. 第一次挥手：浏览器发完数据后，发送FIN给服务器请求断开连接；
2. 第二次挥手：服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ACK的值等于FIN+seq；
3. 第三次挥手：服务器向客户端再发送一个FIN，告知客户端应用程序已关闭；
4. 第四次挥手：客户端收到服务器发送过来的FIN时，回复一个ACK给服务器，其中ACK的值是FIN+seq
```

**\7. TCP关闭连接时为什么要进行4次挥手？**

```markdown
为了确保数据能够被完整传输。当被动方（在本文中可理解为服务器）接收到请求断开连接的一方（在本文中可理解为客户端，即浏览器）传输过来的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
```

**\8. 为什么连接的时候是三次，而断开的时候是4次？**

```markdown
当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
```

**\9 . OSI模型**

络架构模型除了**TCP/IP模型**之外，还有**OSI模型**。**OSI**模型实际上是多了三层。

![](./IMGS/osi_modal.png)

- **数据链路层**: 在不可靠的物理链路上，提供可靠的数据传输服务。包括组帧、物理编址、流量控制、差错控制、接入控制等等。
- **物理层**: 主要功能就是连接网络设备。



