# 一、概述

\1. HTTP是一个超文本传输协议，所有的WWW文件都必须遵守这个标准。

\2. HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。

\3. HTTP是一个无状态协议，同一个客户端的这次请求和上次请求没有任何关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie/session/websocket等来解决。

\4. 默认HTTP的端口号为80，HTTPS（更安全的http协议）的端口号为443。

**# 本质：**

HTTP就是一个通信规则，规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫“请求协议”；服务器发送给客户端的格式叫“响应协议”。

**# Http协议在TCP/IP协议栈中的位置**

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：

![](IMGS/http_tcp_ip.jpg)

**# Http 请求响应模型**

HTTP协议永远都是客户端发起请求，服务器响应。见下图：

![](IMGS/http_model.jpg)

这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。

**# Http 特点**

- **无状态协议**：就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。
- **应用层协议**：由请求和响应构成，是一个标准的客户端服务器模型
- **多次HTTP请求**：在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。
- **基于TCP**：HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。

**# Http 工作流程**

**1. 服务器 < -- > 客户端**

一次HTTP操作称为一个事务，其工作过程可分为四步：

1. 首先客户端与服务器需要 `建立连接` 。只要单击某个超链接，HTTP的工作就开始啦。


2. 建立连接后，客户端发送一个 `请求` 给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容。


3. 服务器接到请求后，给予相应的 `响应` 信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户端与服务器`断开连接`。

> 建立连接 -> 客户端发送请求 -> 服务器响应请求 -> 渲染 -> 断开连接

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

**2. 服务器 < -- > 代理 < -- > 客户端**

我们的请求有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示：

![](./IMGS/http_delete.png)

**3. 代理服务器的作用**

代理服务器就是网络信息的中转站，有什么功能呢？

1. 提高访问速度， 大多数的代理服务器都有缓存功能。
2. 突破限制， 也就是FQ（翻墙）了。
3. 隐藏身份。
4. 过滤（像反病毒扫描，家长控制）
5. 负载均衡（让多个服务器服务不同的请求）
6. 认证（对不同资源进行权限管理）
7. 日志记录（允许存储历史信息）

# 二、URL

## 1. 说明

URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，基本格式如下：

```
schema://host[:port#]/path/.../[?query-string][#anchor]
```

- schema：协议（例如：http, https, ftp）
- host：IP地址或者域名
- port：端口号，默认为80
- path：资源路径
- query-string：发送给Http服务器的数据（get参数）
- anchor：锚

## 2. 示例

```js
"http://127.0.0.1:8081/weather?city=chengdu&date=2019-10-01#stuff"
```

- schema：http
- host：127.0.0.1
- port：8081
- path：/weather
- query-string：city=chengdu&date=2019-10-01
- anchor：stuff

# 三、Http 报文

有两种HTTP报文的类型，请求与响应，每种都有其特定的格式。

## 1. 请求报文

客户端发向服务端，请求报文的格式如下：



请求报文的格式如下：

```markdown
# 请求行
methods path protocol/version
# 请求头（消息报头）
key:value...
# 空行：用来与请求体分隔开
# 请求体（请求正文）
GET没有请求体，只有POST有请求体。
```

浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读。示例如下：

```markdown
# GET
GET http://localhost:3000/api/user HTTP/1.1
Content-Type: application/json

# POST
POST http://localhost:3000/api/user/login HTTP/1.1
Content-Type: application/json

{
    "username":"lihy",
    "password":"456"
}
```

## 2. 响应报文

服务端发向客户端，响应报文格式如下：

```markdown
# 响应行（状态行）
响应协议和版本，状态码 状态消息 例如： HTTP/1.1 200 OK
# 响应头
key:value..
# 空行：用来与响应体分隔开
# 响应体（响应正文）
响应的内容
```

示例如下：

```js
HTTP/1.1 200 OK
Vary: Origin
Access-Control-Allow-Origin: *
Content-Type: application/json; charset=utf-8
Content-Length: 325
Date: Mon, 17 Feb 2020 01:50:30 GMT
Connection: close

{
  "message": "查询成功",
  "users": [
    {
      "gender": "保密",
      "_id": "5e45880cdc0d6b4bec985505",
      "username": "lihy",
      "password": "456",
      "__v": 0
    }
  ]
}
```



# 四、请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET *   | 请求指定的页面信息，并返回实体主体。                         |
| HEAD    | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| POST *  | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 |
| PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| DELETE  | 请求服务器删除指定的页面。                                   |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。     |
| OPTIONS | 允许客户端查看服务器的性能。                                 |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |

# 五、状态码

## 1. 状态码是什么？

状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。HTTP/1.1中定义了5类状态码， HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。

当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。

## 2. 状态码类型

| 状态码 | 描述       | 说明                               |
| ------ | ---------- | ---------------------------------- |
| 1xx    | 信息       | 表示请求正在处理                   |
| 2xx    | 成功       | 操作被成功接收并处理               |
| 3xx    | 重定向     | 要完成请求必须进行更进一步的处理   |
| 4xx    | 客户端错误 | 请求包含语法错误或请求无法实现     |
| 5xx    | 服务器错误 | 服务器在处理请求的过程中发生了错误 |

## 3. 常见状态码

| 状态码   | 描述                                               |
| -------- | -------------------------------------------------- |
| `200 ok` | 请求已经正常处理完毕                               |
| `301`    | 请求永久重定向                                     |
| `302`    | 请求临时重定向                                     |
| `303`    | 请求被重定向到客户端本地缓存                       |
| `400`    | 客户端请求存在语法错误                             |
| `401`    | 客户端请求没有经过授权                             |
| `403`    | 客户端的请求被服务器拒绝，一般为客户端没有访问权限 |
| `404`    | 客户端请求的URL在服务端不存在                      |
| `500`    | 服务端永久错误                                     |
| `503`    | 服务端发生临时错误                                 |

状态码参考地址：\<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\>

# 六、拦截请求 - Fiddler

Fiddler是位于客户端和服务器端之间的代理，也是目前最常用的抓包工具之一 。它能够记录客户端和服务器之间的所有 请求，可以针对特定的请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。

点击前往下载页：https://www.telerik.com/download/fiddler

![](./IMGS/fiddler_install_01.png)

# 七、无状态 VS Keep-Alive

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。
从HTTP/1.1起，默认都开启了`Keep-Alive`，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

# 八、延伸知识

**\1. 浏览器输入地址到页面加载过程中发生了什么？**

```markdown
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器接收请求并响应
5. 浏览器解析并进行渲染
6. 连接结束
```

**\2. 如何DNS解析？** 

```markdown
将用户输入的地址解析成服务器所在的ip地址，DNS解析是一个递归查询的过程，这个过程所需要的步骤比较繁琐，并且存在着多次TCP和UDP（无连接传输协议）请求，十分占用资源。
# DNS优化：
1. DNS缓存：
一般可分为：浏览器缓存、系统缓存、路由器缓存、IPS缓存、跟域名缓存、顶级域名缓存和主域名服务器缓存
2. DNS负载均衡：
我们平常使用的CDN内容分发网络，使用到的就是DNS负载均衡技术。这个过程中使用多台服务器来提供响应，它的原理是当接收到用户发送过来的请求时，可以返回一个最适合用户的IP地址给用户（根据用户的地理位置或其他影响传输效率的因素分配的），这个过程就是DNS负载均衡，也叫做DNS重定向。
```

**\3. TCP如何保证消息的有序和不丢包？**

```markdown
1. SYN「sequence number」：包的序号，用来解决网络包乱序问题。
2. ACK「acknowledge number」：用于确认收到，用来解决不丢包的问题。
```

**\4. 如何理解TCP连接（三次握手）？**

![](./IMGS/tcp-handshake.png)

```markdown
TCP连接主要通过以下三次握手实现：

1. 第一次握手：客户端发送syn包到服务器，等待服务器确认接收。
2. 第二次握手：服务器确认接收syn包并确认客户的syn包，并发送回来一个syn+ack的包给客户端。
3. 第三次握手：客户端确认接收服务器的syn+ack包，并向服务器发送确认包ack

当三次握手完成后便TCP连接便完成了，客户端可以与服务器进行传输数据。四次握手就是中间多了一层等待服务器再一次响应回复相关数据的过程。
```

**\5. 为什么建立http建立连接需要三次握手？**

```
三次是最少的安全次数，两次不安全，四次浪费资源；
```

**\6. TCP关闭连接的过程（四次挥手）？**

![](./IMGS/tcp-wave.png)

```markdown
1. 第一次挥手：浏览器发完数据后，发送FIN给服务器请求断开连接；
2. 第二次挥手：服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ACK的值等于FIN+seq；
3. 第三次挥手：服务器向客户端再发送一个FIN，告知客户端应用程序已关闭；
4. 第四次挥手：客户端收到服务器发送过来的FIN时，回复一个ACK给服务器，其中ACK的值是FIN+seq
```

**\7. TCP关闭连接时为什么要进行4次挥手？**

```markdown
为了确保数据能够被完整传输。当被动方（在本文中可理解为服务器）接收到请求断开连接的一方（在本文中可理解为客户端，即浏览器）传输过来的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
```

**\8. 为什么连接的时候是三次，而断开的时候是4次？**

```markdown
当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
```

**\9 . 网络七层协议（OSI）？**

```markdown
1. 应用层
2. 表示层
3. 会话层
4. 传输层
5. 网络层
6. 数据链路层
7. 物理层
```





