webpackJsonp([21],{yhfw:function(t,n){t.exports='<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n\t<key>comment</key>\n\t<string>\n\t\t\thttps://github.com/abusalimov/SublimeCImproved\n\n\t\t\tDerived from C.tmLanguage - the original TextMate and Sublime Text\n\t\t\tsyntax definition.\n\n\t\t\tThe MIT License (MIT)\n\n\t\t\tCopyright (c) 2013-2014 Eldar Abusalimov\n\t\t\tModified for the Pawn Language by Sergei Marochkin 2016\n\n\t\t\tPermission is hereby granted, free of charge, to any person obtaining a copy of\n\t\t\tthis software and associated documentation files (the "Software"), to deal in\n\t\t\tthe Software without restriction, including without limitation the rights to\n\t\t\tuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n\t\t\tthe Software, and to permit persons to whom the Software is furnished to do so,\n\t\t\tsubject to the following conditions:\n\n\t\t\tThe above copyright notice and this permission notice shall be included in all\n\t\t\tcopies or substantial portions of the Software.\n\n\t\t\tTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n\t\t\tFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n\t\t\tCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n\t\t\tIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n\t\t\tCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t</string>\n\t<key>fileTypes</key>\n\t<array>\n\t\t<string>p</string>\n\t\t<string>pwn</string>\n\t\t<string>inc</string>\n\t</array>\n\t<key>firstLineMatch</key>\n\t<string>-[*]-( Mode:)? C -[*]-</string>\n\t<key>foldingStartMarker</key>\n\t<string>(?x)\n\t\t /\\*\\*(?!\\*)\n\t\t|^(?![^{]*?//|[^{]*?/\\*(?!.*?\\*/.*?\\{)).*?\\{\\s*($|//|/\\*(?!.*?\\*/.*\\S))\n\t</string>\n\t<key>foldingStopMarker</key>\n\t<string>(?&lt;!\\*)\\*\\*/|^\\s*\\}</string>\n\t<key>keyEquivalent</key>\n\t<string>^~C</string>\n\t<key>name</key>\n\t<string>Pawn</string>\n\n\t<key>patterns</key>\n\t<array>\n\t\t<dict> <key>include</key> <string>#translation_unit</string> </dict>\n\t</array>\n\n\t<key>repository</key>\n\t<dict>\n\t\t<key>translation_unit</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#function</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#support</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#block</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#parens</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t\x3c!--\n\t\t\txxx-lookahead-end rules are introduced to workaround ST2 bugs,\n\t\t\tsee https://github.com/abusalimov/SublimeCImproved/issues/10\n\t\t--\x3e\n\t\t<key>block</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(?=\\{)</string>\n\t\t\t<key>end</key> <string>\\}</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#block-lookahead-end</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>block-lookahead-end</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>\\{</string>\n\t\t\t<key>end</key> <string>(?=\\})</string>\n\t\t\t<key>name</key> <string>meta.block.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#call</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#support</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#function</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>$base</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>parens</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(?=\\()</string>\n\t\t\t<key>end</key> <string>\\)</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#parens-lookahead-end</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>parens-lookahead-end</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>\\(</string>\n\t\t\t<key>end</key> <string>(?=\\))</string>\n\t\t\t<key>name</key> <string>meta.parens.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#call</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#support</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>$base</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>function</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#function-fixup-macro</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#function-declaration</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#function-definition</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>function-fixup-macro</key>\n\t\t<dict>\n\t\t\t<key>begin</key>\n\t\t\t<string>(?x)\n\t\t\t\t^ # Begin of line, capital letters: most probably it is a macro\n\t\t\t\t\\s*\\b\n\t\t\t\t([A-Z0-9_]++)\n\t\t\t\t\\b\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t</string>\n\t\t\t<key>end</key> <string>\\)</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#parens-lookahead-end</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>function-declaration</key>\n\t\t<dict>\n\t\t\t<key>name</key> <string>meta.function.c</string>\n\t\t\t<key>begin</key>\n\t\t\t<string>(?x)\n\t\t\t\t(?: ^\n\t\t\t\t  | (?&lt;! (?&lt;!\\w) new\n\t\t\t\t        | (?&lt;!\\w) (?:else|enum) | (?&lt;!\\w) (?:class|union)\n\t\t\t\t        | (?&lt;!\\w) (?:struct|return|sizeof|typeof)\n\t\t\t\t        | (?&lt;!\\w) __typeof | (?&lt;!\\w) __typeof__ )\n\t\t\t\t    (?&lt;= \\w ) \\s\n\n\t\t\t\t  | #  or type modifier / closing bracket before name\n\t\t\t\t    (?&lt;= [^&amp;]&amp; | [*&gt;)}\\]] ) ) \\s*\n\n\t\t\t\t(   (?: [A-Za-z_@]\\w*+ | ::[^:] )++\n\t\t\t\t    (?: (?&lt;= ^ operator | \\W operator )  # C++ operator?\n\t\t\t\t        (?: [-*&amp;&lt;&gt;=+!]+ | \\(\\) | \\[\\] ) )? )\n\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ (?\'parens\' \\(\n\t\t\t\t            (?&gt; \\g\'parens\' |\n\t\t\t\t            \t"(\\\\.|[^"])*" | \'(\\\\.|[^\'])*\' | /\\*.*?\\*/ |\n\t\t\t\t            \t(?! /[/*] | [()] ) . )*\n\t\t\t\t        \\) ) \\s* ; )\n\t\t\t</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>entity.name.function.declaration.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>;</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#parens</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>function-definition</key>\n\t\t<dict>\n\t\t\t<key>name</key> <string>meta.function.c</string>\n\t\t\t<key>begin</key>\n\t\t\t<string>(?x)\n\t\t\t\t(?: ^\n\t\t\t\t  | (?&lt;! (?&lt;!\\w) new\n\t\t\t\t        | (?&lt;!\\w) (?:else|enum) | (?&lt;!\\w) (?:class|union)\n\t\t\t\t        | (?&lt;!\\w) (?:struct|return|sizeof|typeof)\n\t\t\t\t        | (?&lt;!\\w) __typeof | (?&lt;!\\w) __typeof__ )\n\t\t\t\t    (?&lt;= \\w ) \\s\n\n\t\t\t\t  | #  or type modifier / closing bracket before name\n\t\t\t\t    (?&lt;= [^&amp;]&amp; | [*&gt;)}\\]\\:] ) ) \\s*\n\n\t\t\t\t(   (?: [A-Za-z_@]\\w*+ | ::[^:] )++\n\t\t\t\t    (?: (?&lt;= ^ operator | \\W operator )  # C++ operator?\n\t\t\t\t        (?: [-*&amp;&lt;&gt;=+!]+ | \\(\\) | \\[\\] ) )? )\n\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>entity.name.function.definition.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>\\}|;</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#parens</string> </dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(const|override)\\b</string>\n\t\t\t\t\t<key>name</key> <string>storage.modifier.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict> <key>include</key> <string>#block-lookahead-end</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>call</key>\n\t\t<dict>\n\t\t\t<key>name</key> <string>meta.function-call.c</string>\n\t\t\t<key>begin</key>\n\t\t\t<string>(?x)\n\t\t\t\t\\s*\n\t\t\t\t(?= # don\'t consume to recognize support functions\n\t\t\t\t    (?: [A-Za-z_@]\\w*+ | ::[^:] )++\n\t\t\t\t    (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t</string>\n\t\t\t<key>end</key> <string>\\)</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex</string> </dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?:(?&lt;=\\.)|(?&lt;=-&gt;))\\b([A-Za-z_@]\\w*+)\\b</string>\n\t\t\t\t\t<key>name</key> <string>variable.other.dot-access.c support.function.any-method.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?:[A-Za-z_@]\\w*+|::[^:])++</string>\n\t\t\t\t\t<key>name</key> <string>support.function.any-method.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict> <key>include</key> <string>#parens-lookahead-end</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>preprocessor</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(?=^\\s*(#))</string>\n\t\t\t<key>end</key> <string>(?!^\\s*(#))</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-directive-invalid-usage</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-macro</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-undef</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-pragma-mark</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-include</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-error</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-directive</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-directive-obsolete</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-directive-emit</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-invalid</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-any</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>preprocessor-lex</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#comments</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-newline</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>ppline-macro</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)(?=\\s*(define)\\s+[a-zA-Z_]\\w*+)</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.macro.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*(##)</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*(#)\\s*([a-zA-Z_]\\w*+)</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>string.macro.stringify.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-macro-head-function</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-macro-head-object</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-macro-param</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-in-preprocessor</string> </dict>\n\n\t\t\t\t<dict> <key>include</key> <string>#support</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-macro-head-object</key>\n\t\t<dict>\n\t\t\t<key>match</key> <string>(?&lt;!##)(?&lt;=#)(\\s*define)\\s+([a-zA-Z_]\\w*+)(?!\\()[\\s&amp;&amp;[^\\n]]*</string>\n\t\t\t<key>captures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.define.c</string> </dict>\n\t\t\t\t<key>2</key> <dict> <key>name</key> <string>entity.name.constant.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t</dict>\n\t\t<key>ppline-macro-head-function</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(?&lt;!##)(?&lt;=#)(\\s*define)\\s+([a-zA-Z_]\\w*+)(\\()</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.define.c</string> </dict>\n\t\t\t\t<key>2</key> <dict> <key>name</key> <string>entity.name.function.preprocessor.c</string> </dict>\n\t\t\t\t<key>3</key> <dict> <key>name</key> <string>meta.preprocessor.macro.parameters.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=\\))|(?&lt;=^|[^\\\\])\\s*(\\n)?</string>\n\t\t\t<key>endCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>invalid.illegal.unexpected-end-of-line.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>contentName</key> <string>meta.preprocessor.macro.parameters.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-macro-param</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-macro-param</key>\n\t\t<dict>\n\t\t\t<key>match</key> <string>(%[0-9]+)</string>\n\t\t\t<key>captures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>variable.parameter.c</string> </dict>\n\t\t\t</dict>\n\t\t</dict>\n\n\t\t<key>ppline-undef</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(^\\s*(#)\\s*(undef))\\s+([a-zA-Z_]\\w*+)</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t<key>4</key> <dict> <key>name</key> <string>variable.macro.undef.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.undef.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>ppline-include</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)\\s*(include|tryinclude)\\b</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.preprocessor.include.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?:("[^"]*?)|(&lt;[^&gt;]*?))(\\n)|(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>endCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>string.quoted.double.include.c</string> </dict>\n\t\t\t\t<key>2</key> <dict> <key>name</key> <string>string.quoted.other.lt-gt.include.c</string> </dict>\n\t\t\t\t<key>3</key> <dict> <key>name</key> <string>invalid.illegal.unexpected-end-of-line.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>name</key> <string>meta.preprocessor.include.c meta.preprocessor.c.include</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#ppline-include-innards</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-include-innards</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#preprocessor-lex</string> </dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>"|(?=.*?")</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.begin.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>"|(?&lt;=^|[^\\\\])(?=\\s*\\n)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.end.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>name</key> <string>string.quoted.double.include.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>&lt;(?=.*?&gt;)</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.begin.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>&gt;|(?&lt;=^|[^\\\\])(?=\\s*\\n)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.end.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>name</key> <string>string.quoted.other.lt-gt.include.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>\\(</string>\n\t\t\t\t\t<key>end</key> <string>\\)|(?&lt;=^|[^\\\\])(?=\\s*\\n)</string>\n\t\t\t\t\t<key>name</key> <string>meta.parens.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#ppline-include-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-error</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)\\s*(error|warning)\\b</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.preprocessor.include.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(.*)|(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>endCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>string.quoted.double.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>name</key> <string>meta.preprocessor.include.c meta.preprocessor.c.include</string>\n\t\t</dict>\n\t\t<key>ppline-pragma-mark</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>(^\\s*(#)\\s*(pragma\\s+(align|amxlimit|amxram|codepage|compress|ctrlchar|deprecated|dynamic|library|overlay|pack|rational|semicolon|tabsize|unused))\\b)[\\s&amp;&amp;[^\\n]]*</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.pragma.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-directive</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)\\s*(if|elseif|else|endif|pragma|line|define|undef|section|assert|file|endinput|endscript)\\b</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-in-preprocessor</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>ppline-directive-emit</key>\n\t\t<dict>\n\t\t\t<key>begin</key>\n\t\t\t<string>(?x)\n\t\t\t\t^\\s*(\\#|@)\\s*(emit) #pre-processor directive\n\t\t\t\t(\\s+\n\t\t\t\t\t([A-Z0-9a-z]+)\n\t\t\t\t\t(\n\t\t\t\t\t\t(\\.)([A-Za-z]+)\n\t\t\t\t\t\t((\\.)([A-Za-z]+))?\n\t\t\t\t\t)?\n\t\t\t\t|\\s*)\n\t\t\t</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t<key>2</key> <dict> <key>name</key> <string>keyword.control.import.c</string> </dict>\n\t\t\t\t<key>4</key> <dict> <key>name</key> <string>entity.name.function.preprocessor.c</string> </dict>\n\t\t\t\t<key>6</key> <dict> <key>name</key> <string>punctuation.separator.parameters.c</string> </dict>\n\t\t\t\t<key>7</key> <dict> <key>name</key> <string>entity.name.function.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.emit.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-in-preprocessor</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>ppline-directive-invalid-usage</key>\n\t\t<dict>\n\t\t\t<key>match</key> <string>(^\\s*(#)\\s*(if|elseif|pragma|define|undef|include|tryinclude)\\b)\\s*?(\\n|$)</string>\n\t\t\t<key>captures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t<key>4</key> <dict> <key>name</key> <string>invalid.illegal.invalid-usage-of-preprocessor-directive.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.c</string>\n\t\t</dict>\n\n\t\t<key>ppline-invalid</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)(?!\\s*(?=/[/*]|(?&gt;\\\\\\s*\\n)|\\n|$))\\s*(\\w*)</string>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.illegal.c</string>\n\t\t</dict>\n\n\t\t<key>ppline-any</key>\n\t\t<dict>\n\t\t\t<key>begin</key> <string>^\\s*(#)</string>\n\t\t\t<key>beginCaptures</key>\n\t\t\t<dict>\n\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t</dict>\n\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t<key>name</key> <string>meta.preprocessor.directive.null-directive.c</string>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>support</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#support-modifier</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#support-keyword</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>support-modifier</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(inline|using)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.modifier.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>support-keyword</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(foreach)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.control.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>comments</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>\\s*(/\\*)</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>punctuation.definition.comment.block.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(\\*/)(\\n?)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>punctuation.whitespace.newline.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>name</key> <string>comment.block.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\*/(?![/*])</string>\n\t\t\t\t\t<key>name</key> <string>invalid.illegal.stray-comment-end.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>\\s*(//)</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>punctuation.definition.comment.line.double-slash.c++</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(?&lt;=$\\n)(?&lt;!\\\\$\\n)</string>\n\t\t\t\t\t<key>name</key> <string>comment.line.double-slash.c++</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>comment-innards</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#comment-banner-line</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-newline</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>comment-banner-line</key>\n\t\t<dict>\n\t\t\t<key>match</key> <string>(?:(?&lt;=//)|(?&lt;=/\\*)|^)[\\s/*]*(=+\\s*(.*?)\\s*=+(?:(?=[\\s/*+\\-]*\\*/)|$(\\n?)))</string>\n\t\t\t<key>captures</key>\n\t\t\t<dict>\n\t\t\t\t<key>1</key> <dict> <key>name</key> <string>meta.toc-list.banner.c</string> </dict>\n\t\t\t\t<key>3</key> <dict> <key>name</key> <string>punctuation.whitespace.newline.c</string> </dict>\n\t\t\t</dict>\n\t\t</dict>\n\n\t\t<key>comment-task-tag-line</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (FIXME) | (XXX) | (WTF)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.task-tag.prio-high.c</string> </dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.class.fixme.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>storage.type.class.xxx.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>storage.type.class.wtf.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(?=[\\s/*]*\\*/)|(?&lt;=$\\n)</string>\n\t\t\t\t\t<key>name</key> <string>meta.toc-list.task-tag.prio-high.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (TODO)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.task-tag.prio-normal.c</string> </dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.class.todo.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(?=[\\s/*]*\\*/)|(?&lt;=$\\n)</string>\n\t\t\t\t\t<key>name</key> <string>meta.toc-list.task-tag.prio-normal.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (TBD) | (REVIEW)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.task-tag.prio-low.c</string> </dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.class.tbd.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>storage.type.class.review.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(?=[\\s/*]*\\*/)|(?&lt;=$\\n)</string>\n\t\t\t\t\t<key>name</key> <string>meta.toc-list.task-tag.prio-low.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (NOTE) | (NB) | (CHANGED) | (IDEA) | (IMPORTANT) | (HACK) | (BUG)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>keyword.other.task-tag.note.c</string> </dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.class.note.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>storage.type.class.nb.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>storage.type.class.changed.c</string> </dict>\n\t\t\t\t\t\t<key>4</key> <dict> <key>name</key> <string>storage.type.class.idea.c</string> </dict>\n\t\t\t\t\t\t<key>5</key> <dict> <key>name</key> <string>storage.type.class.important.c</string> </dict>\n\t\t\t\t\t\t<key>6</key> <dict> <key>name</key> <string>storage.type.class.hack.c</string> </dict>\n\t\t\t\t\t\t<key>7</key> <dict> <key>name</key> <string>storage.type.class.bug.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(?=[\\s/*]*\\*/)|(?&lt;=$\\n)</string>\n\t\t\t\t\t<key>name</key> <string>meta.toc-list.task-tag.note.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line-innards</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>comment-task-tag-line-innards</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#comment-task-tag-line</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-newline</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\n\t\t<key>lex</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-in-preprocessor</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#preprocessor</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-in-preprocessor</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-keyword</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#support-keyword</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-constant</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-core</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict> <key>include</key> <string>#comments</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-newline</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-number</string> </dict>\n\t\t\t\t<dict> <key>include</key> <string>#lex-string</string> </dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-continuation</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(\\\\)$(\\n?)</string>\n\t\t\t\t\t<key>name</key> <string>punctuation.separator.continuation.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.line-continuation.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>punctuation.whitespace.newline.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\\\(\\s+?)(?=\\n)$</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>invalid.deprecated.space-after-continuation.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-newline</key>\n\t\t<dict>\n\t\t\t<key>match</key> <string>$\\n</string>\n\t\t\t<key>name</key> <string>punctuation.whitespace.newline.c</string>\n\t\t</dict>\n\n\t\t<key>lex-keyword</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(defined)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.other.preprocessor.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(sizeof|tagof)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.operator.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(Iterator:)(\\t)</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.invalid-indentation</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>^\\s*(case)\\s+</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.control.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(:)|(?&lt;=^|[^\\\\])\\s*(\\n)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.operator.ternary.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#lex-core</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(assert|break|case|continue|default|do|else|exit|for|goto|if|return|sleep|state|switch|while)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>keyword.control.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(new|enum)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(public|forward|native|char|const|static|stock|hook|task|ptask)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.modifier.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>([A-Za-z_]\\w*)\\:</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>storage.modifier.c</string>\n\t\t\t\t</dict>\n\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(\\-|\\+|\\*|\\/|%|&amp;|\\||\\^|&lt;&lt;|&gt;&gt;)?=</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.assignment.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(==|!=|&lt;=|&gt;=|&lt;&gt;|&lt;|&gt;)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.comparison.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(\\-\\-|\\+\\+)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.increment-decrement.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(\\?|:)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.ternary.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(\\-|\\+|\\*|\\/|%)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.arithmetic.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(!|&amp;&amp;|\\|\\|)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.logical.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(~|&amp;|\\||\\^|&lt;&lt;|&gt;&gt;)</string>\n\t\t\t\t\t<key>name</key>\n\t\t\t\t\t<string>keyword.operator.bitwise.c</string>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-constant</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\s*\\b(true|false|TRUE|FALSE)\\b</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>constant.language.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-number</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>([0-9]+)(\\.{2})([0-9]+)</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>constant.numeric.integer.decimal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>keyword.operator.switch-range.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>constant.numeric.integer.decimal.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)  # hexadecimal float\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(0x)\n\n\t\t\t\t\t\t# significand\n\t\t\t\t\t\t(?: (\\.) (?=p)  # invalid\n\t\t\t\t\t\t  |        [0-9a-f]*+ ([0-9a-z]*?) [0-9a-f]*+\n\t\t\t\t\t\t    (?: \\. [0-9a-f]*+ ([0-9a-z.]*?) [0-9a-f]*+ )? )\n\n\t\t\t\t\t\t# exponent (required)\n\t\t\t\t\t\t(?: (p) (?:        [+\\-]  [0-9]++ ([0-9a-z]*?)\n\t\t\t\t\t\t          | (?=[0-9a-z.]) [0-9]*+ ([0-9a-z.]*?) )\n\t\t\t\t\t\t  | (p) )\n\n\t\t\t\t\t\t# remaining valid chars and type\n\t\t\t\t\t\t[0-9]*+ ([fl]?)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.float.hexadecimal.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.hexadecimal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.number.missing-fragment.significand.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.whole-number.c</string> </dict>\n\t\t\t\t\t\t<key>4</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.fraction.c</string> </dict>\n\t\t\t\t\t\t<key>5</key> <dict> <key>name</key> <string>keyword.other.exponent.hexadecimal.c</string> </dict>\n\t\t\t\t\t\t<key>6</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>7</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>8</key> <dict> <key>name</key> <string>invalid.illegal.number.missing-fragment.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>9</key> <dict> <key>name</key> <string>storage.type.number.suffix.float.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)  # hexadecimal float without required exponent\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(0x)\n\n\t\t\t\t\t\t# significand (at least a period)\n\t\t\t\t\t\t     [0-9a-f]*+ ([0-9a-z&amp;&amp;[^p]]*?) [0-9a-f]*+\n\t\t\t\t\t\t(\\.) [0-9a-f]*+ ([0-9a-z.&amp;&amp;[^p]]*?) [0-9a-f]*+\n\n\t\t\t\t\t\t# type\n\t\t\t\t\t\t(l?)\n\n\t\t\t\t\t\t(?:(?&lt;=\\.)|\\b) (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.float.hexadecimal.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.hexadecimal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.whole-number.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>invalid.illegal.number.hexadecimal-float-requires-exponent.c</string> </dict>\n\t\t\t\t\t\t<key>4</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.fraction.c</string> </dict>\n\t\t\t\t\t\t<key>5</key> <dict> <key>name</key> <string>storage.type.number.suffix.float.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)  # decimal float literal\n\t\t\t\t\t\t(?&lt;!\\.) (?:(?=\\.)|\\b)\n\n\t\t\t\t\t\t(?!0x)\n\t\t\t\t\t\t# significand\n\t\t\t\t\t\t(?: (?: [0-9]++ ([0-9a-z&amp;&amp;[^e]]*?) [0-9]*+ )?\n\t\t\t\t\t\t    \\.  [0-9]++ ([0-9a-z.&amp;&amp;[^e]]*?) [0-9]*+\n\n\t\t\t\t\t\t  |     [0-9]++ ([0-9a-z&amp;&amp;[^e]]*?) [0-9]*+ (?: \\. | (?=e)) )\n\n\t\t\t\t\t\t# exponent (optional)\n\t\t\t\t\t\t(?: (e) (?: [+\\-]  [0-9]++ ([0-9a-z]*?)\n\t\t\t\t\t\t          |        [0-9]++ ([0-9a-z.]*?) )\n\t\t\t\t\t\t  | ( p     [+\\-]? [0-9]++\n\t\t\t\t\t\t    | [ep]                  [0-9a-z.]*?) )?\n\n\t\t\t\t\t\t# any invalid chars and type\n\t\t\t\t\t\t([0-9a-z]*?) [0-9]*+ ([fl]?)\n\n\t\t\t\t\t\t(?:(?&lt;=\\.)|\\b) (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.float.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.whole-number.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.fraction.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.whole-number.c</string> </dict>\n\t\t\t\t\t\t<key>4</key> <dict> <key>name</key> <string>keyword.other.exponent.decimal.c</string> </dict>\n\t\t\t\t\t\t<key>5</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>6</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>7</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>8</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.float.exponent.c</string> </dict>\n\t\t\t\t\t\t<key>9</key> <dict> <key>name</key> <string>storage.type.number.suffix.float.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\t\t\t\t\t\t(0x)? 0++\n\t\t\t\t\t\t(u?l{0,2}|lul?|llu)\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.integer.zero.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.hexadecimal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>storage.type.number.suffix.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(?: (0x) | (0b) )\n\t\t\t\t\t\t(u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>invalid.illegal.invalid-number-literal.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(0x) [0-9a-f]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-9a-f]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.integer.hexadecimal.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.hexadecimal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.integer.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>storage.type.number.suffix.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(0b) [01]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[01]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.integer.binary.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.binary.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.integer.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>storage.type.number.suffix.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t(?&lt;!\\.) \\b\n\n\t\t\t\t\t\t(0) [0-7]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-7]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.integer.octal.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>storage.type.number.prefix.octal.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.integer.c</string> </dict>\n\t\t\t\t\t\t<key>3</key> <dict> <key>name</key> <string>storage.type.number.suffix.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>(?ix)\n\t\t\t\t\t\t\\b\n\n\t\t\t\t\t\t[0-9][0-9_]*\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-9]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.numeric.integer.decimal.c</string>\n\t\t\t\t\t<key>captures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>invalid.illegal.numeric-literal-character.integer.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>storage.type.number.suffix.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>lex-string</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>"</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.begin.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(")|(?&lt;=^|[^\\\\])\\s*(\\n)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>punctuation.definition.string.end.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.unexpected-end-of-line.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>name</key> <string>string.quoted.double.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#string_escaped_char</string> </dict>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#string_placeholder</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>begin</key> <string>\'</string>\n\t\t\t\t\t<key>beginCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>0</key> <dict> <key>name</key> <string>punctuation.definition.string.begin.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>end</key> <string>(\')|(?&lt;=^|[^\\\\])\\s*(\\n)</string>\n\t\t\t\t\t<key>endCaptures</key>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>1</key> <dict> <key>name</key> <string>punctuation.definition.string.end.c</string> </dict>\n\t\t\t\t\t\t<key>2</key> <dict> <key>name</key> <string>invalid.illegal.unexpected-end-of-line.c</string> </dict>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<key>name</key> <string>string.quoted.single.c</string>\n\t\t\t\t\t<key>patterns</key>\n\t\t\t\t\t<array>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#lex-continuation</string> </dict>\n\t\t\t\t\t\t<dict> <key>include</key> <string>#string_escaped_char</string> </dict>\n\t\t\t\t\t</array>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>string_escaped_char</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\\\(\\\\|[abefnprtv\'"?]|[0-3]\\d{0,2}|[4-7]\\d?|x[a-fA-F0-9]{0,2}|u[a-fA-F0-9]{0,4}|U[a-fA-F0-9]{0,8})</string>\n\t\t\t\t\t<key>name</key> <string>constant.character.escape.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>\\\\.</string>\n\t\t\t\t\t<key>name</key> <string>invalid.illegal.unknown-escape.c</string>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t\t<key>string_placeholder</key>\n\t\t<dict>\n\t\t\t<key>patterns</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key>\n\t\t\t\t\t<string>(?x)%\n\t\t\t\t\t\t(\\d+\\$)?                             # field (argument #)\n\t\t\t\t\t\t[#0\\- +\']*                           # flags\n\t\t\t\t\t\t[,;:_]?                              # separator character (AltiVec)\n\t\t\t\t\t\t((-?\\d+)|\\*(-?\\d+\\$)?)?              # minimum field width\n\t\t\t\t\t\t(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?         # precision\n\t\t\t\t\t\t[diouxXDOUeEfFgGaACcSspnq%]          # conversion type\n\t\t\t\t\t</string>\n\t\t\t\t\t<key>name</key> <string>constant.other.placeholder.c</string>\n\t\t\t\t</dict>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>match</key> <string>%</string>\n\t\t\t\t\t<key>name</key> <string>invalid.illegal.placeholder.c</string>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t</dict>\n\n\t<key>scopeName</key>\n\t<string>source.pawn</string>\n\t<key>uuid</key>\n\t<string>25066DC2-6B1D-11D9-9D5B-000D93589AF6</string>\n</dict>\n</plist>\n'}});