# 一、概述

## 1. 起源

[Babel >>](<https://www.babeljs.cn/>) 最开始叫 **6to5**，顾名思义是 **es6** 转 **es5**，但是后来随着 es 标准的演进，有了 es7、es8 等， **6to5** 的名字已经不合适了，所 以改名为了 **babel**。

babel 是 [巴别塔](https://baike.baidu.com/item/%E5%B7%B4%E5%88%AB%E5%A1%94/67557) 的意思，来自圣经中的典故：

> 当时人类联合起来兴建希望能通往天堂的高塔；为了阻止人类的计划，上帝让人类说不同的语言，使人类相互之间不能沟通，计划因此失败，人类自此各散东西。此事件，为世上出现不同语言和种族提供解释。 这座塔就是巴别塔。

## 2. 用途

据官方介绍，Babel 是一个 JavaScript 编译器。下面列出的是 Babel 能为你做的事情：

- **语法转换**：把代码中的 `esnext` 的新语法、`TypeScript` 和 `Flow` 的语法等等，转成基于目标环境支持的语法的实现。并且还可以把目标环境不支持的 Api 进行 `polyfill`。
- **特定用途的代码转换**：通过 Babel 提供的API可以完成代码到 AST 的 解析、转换，以及目标代码的生成。 开发者可以用它来完成一些特定用途的转换，比如函数插桩（函数中自动插入一些代码，例如埋点代码）、自动国际化等。
- **代码的静态分析**：除了进行转换然后生成目标代码之外，也同样可以用于分析代码的信息，进行一些检查，比如：
  - `linter` 工具就是分析 AST 的结构，对代码规范进行检查。
  - `Api` 文档自动生成工具，可以提取源码中的注释，然后生成文档。
  - `Type checker` 会根据从 AST 中提取的或者推导的类型信息，对 AST 进行类型是否一致的检查，从而减少运行时因类型导致的错误。
  - `压缩混淆工具`，这个也是分析代码结构，进行删除死代码、变量名混淆、常量折叠等各种编译优化，生成体积更小、性能更优的代码
  - `JS 解释器`，除了对 AST 进行各种信息的提取和检查以外，我们还可以直接解释执行 AST。

## 3. Compiler or Transpiler

- `编译器（Compiler）`：高级语言到低级语言的转换工具。
- `转译器（Transpiler）`：高级语言到高级语言的转换工具。

高级语言：有很多用于描述逻辑的语言特性，比如分支、循环、函数、面向对象等，接近人的思维，可以让开发者快速的通过它来 表达各种逻辑。比如 `Objective-C`、`JavaScript` 等。

低级语言：与硬件和执行细节有关，会操作寄存器、内存，具体做内存与寄存器之间的复制，需要开发者理解熟悉计算机的工作原理，熟悉具体的执行细节。比如汇编语言、机器语言。

> 结论：`Babel`  就是一个  **`JavaScript Transpiler`**。

尽管 [官网 >>](https://www.babeljs.cn/) 标题介绍Babel 是一个 JavaScript 编译器，但侧重点在于 **下一代**。

# 二、AST - 抽象语法树

## 1. What's AST？

**抽象语法树**（**A**bstract **S**yntax **T**ree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 `if-condition-then` 这样的条件跳转语句，可以使用带有三个分支的节点来表示。这种数据结构其实就是一个大的 `JSON` 对象，`JSON` 我们都熟悉，他就像一颗枝繁叶茂的树。有树根，有树干，有树枝，有树叶，无论多小多大，都是一棵完整的树。

简单理解，就是把我们写的代码按照一定的规则转换成一种 **树形结构**。

## 2. 用途

AST在前端无处不在，我们熟悉的开发工具几乎全依赖于AST进行开发：`Webpack`、`Babel`、`Eslint`、`Prettier`。如果你想了解 JavaScript 编译执行的原理，了解其精髓，那么你就必须得了解 AST。

## 3. AST 如何生成？

js 执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成 `token`，之后再通过语法分析生成 AST，最后生成机器码执行。整个解析过程主要分为以下两个步骤：

- `词法分析`：将整个代码字符串分割成最小语法单元数组
- `语法分析`：在分词基础上建立分析语法单元之间的关系

### 3.1. 词法分析/分词

词法分析，也称之为扫描或者令牌化，简单来说就是在源代码的基础上进行分词断句，一个字符一个字符的读取，然后将其分解成有意义的代码块，这些代码块统称为 <u>词法单元</u>。分词断句之后，对每个单词进行分类，是属于关键字还是标识符还是标点符号等等，你可以想象成词法分析就是把你的代码从 `string` 类型转换成了数组，数组的元素就是代码里的单词（词法单元），然后对每个单词标记了类型。

比如：

```javascript
const a = 10;
```

这段程序通常会被分解成为下面这些词法单元：`let` 、`a`、`=`、`1`、 `;`，你可以在 [这里 >>](https://esprima.org/demo/parse.html?code=const%20a%20%3D%2010%3B%0A) 查看词法分析结果：

```javascript
[
  { type: 'Keyword', value: 'const' },
  { type: 'Identifier', value: 'a' },
  { type: 'Punctuator', value: '=' },
  { type: 'Numeric', value: '10' },
  { type: 'Punctuator', value: ';' },
];
```

词法分析结果缺少一些比较关键的信息:

1. 没有任何语法信息；
2. 体现不了代码的执行先顺序；

所以需要进一步进行语法分析。

### 3.2. 语法分析/解析

语法分析会将词法分析出来的 **词法单元** 转化成有语法含义的 **抽象语法树结构（AST）**。同时，验证语法，语法如果有错的话，抛出语法错误。

词法分析和语法分析不是完全独立的，而是交错进行的，也就是说，词法分析器不会在读取所有的词法记号后再使用语法分析器来处理。在通常情况下，每取得一个词法记号，就将其送入语法分析器进行分析。

![](./IMGS/js-token-ast.png)

我们可以使用在线工具生成 AST：[AST explorer >>](https://astexplorer.net/) 或者 [Esprima.org >>](https://esprima.org/demo/parse.html)，这里主要简单介绍下 `AST explorer` 的使用：

![](./IMGS/ast_explorer.png)

比如这一段代码：

```javascript
const a = 10;
```

经过转化，输出如下AST树状结构：

```json
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "value": 10,
            "raw": "10"
          }
        }
      ],
      "kind": "const"
    }
  ],
  "sourceType": "script"
}
```

## 4. 常见类型

词法单元的类型主要包括：字面量、标识符、表达式、语句、模块语法、class 语法等等。 下面主要介绍一些常用的类型

### 4.1. 字面量（`Literal`）

| 类型             | 示例                  |
| ---------------- | --------------------- |
| `StringLiteral`  | `'Hello, AST!'`       |
| `TemplatLiteral` | 模板字符串（`）       |
| `NumericLiteral` | `123`                 |
| `RegExpLiteral`  | 正则表达式：`/[0-9]/` |
| `BooleanLiteral` | `True`                |
| `BigintLiteral`  | `1.234567n`           |
| `NullLiteral`    | `null`                |

### 4.2. 标志符（`Identifier`）

程序中所有的 变量名、函数名、对象键（`key`） 以及函数中的参数名，都属于标志符（`Identifier`）。

### 4.3. 语句（`Statement`）

语句的特点是能够独立执行，是执行的基本单位。

| 类型                | 示例                                     |
| ------------------- | ---------------------------------------- |
| `BreakStatement`    | `break`                                  |
| `ContinueStatement` | `continue`                               |
| `ReturenStatement`  | `return`                                 |
| `DebuggerStatement` | `debugger`                               |
| `ThrowStatement`    | `throw Error()`                          |
| `BlockStatement`    | `{}`                                     |
| `TryStatement`      | `try {} catch(e) {}`                     |
| `ForInStatement`    | `for(let key in obj) {}`                 |
| `ForStatement`      | `for(let i = 0; i < 10; i++) {}`         |
| `WhileStatement`    | `while(true) {}`                         |
| `DoWhileStatement`  | `do {} while {}`                         |
| `SwitchStatement`   | `switch(v) { case 1: break; default:;} ` |

### 4.4. 声明语句（`Declaration`）

声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个 `变量`、函数、`class`、`import`、`export` 等。

| 类型                       | 示例                              |
| -------------------------- | --------------------------------- |
| `VariableDeclaration`      | `const a = 10;`                   |
| `FunctionDeclaration`      | `function sum() {}`               |
| `ClassDeclaration`         | `class Tools {}`                  |
| `ImportDeclaration`        | `import { reactive } from 'vue;'` |
| `ExportDefaultDeclaration` | `export default a = 10;`          |
| `ExportNamedDeclaration`   | `export { name };`                |
| `ExportAllDeclaration`     | `export * from 'tools';`          |

### 4.5. 表达式（`Expression`）

表达式的特点是执行完以后有返回值，这是和语句 (`statement`) 的区别

| 类型                      | 示例                       |
| ------------------------- | -------------------------- |
| `ArrayExpression`         | 数组表达式：`[1, 2, 3]`    |
| `AssignmentExpression`    | 赋值表达式：`a = 1`        |
| `BinaryExpression`        | 二元表达式：`1 + 2`        |
| `UnaryExpression`         | 一元表达式：`-1`           |
| `FunfctionExpression`     | 函数表达式：`function(){}` |
| `ArrayFunctionExpression` | 箭头函数表达式：`() => {}` |
| `ClassExpression`         | class 表达式：`class {}`   |
| `ThisExpression`          | this 表达式：`this`        |
| `BindExpression`          | 绑定表达式：`a::b`         |

### 4.6. `Comment` 节点

| 类型           | 示例             |
| -------------- | ---------------- |
| `CommentBlock` | `/* 块级注释 */` |
| `CommentLine`  | `// 单行注释`    |

# 三、工作原理

![](./IMGS/babel.png)

Babel 的编译过程和大多数其他语言的编译器大致相同，可以分为 **三个阶段**：`解析(Parse)`  →  `转换(Transform)`  →  `生成(Generate)`。

**@解析（`Parser`）**

将代码字符串解析成抽象语法树（AST），每个 JavaScript 引擎（比如Chrome浏览器中的 `V8` 引擎）都有自己的AST解析器，而Babel是通过 [@babel/parser >>](https://www.babeljs.cn/docs/babel-parser) 实现的。解析过程有两个阶段：**词法分析** 和 **语法分析**，词法分析阶段把字符串形式的代码转换为**令牌**（tokens）流，令牌类似于AST中节点；而语法分析阶段则会把一个令牌流转换成 AST的形式，同时这个阶段会把令牌中的信息转换成AST的表述结构。

**@转换（`Transform`）**

对抽象语法树进行转换操作，转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 Babel通过 [@babel/traverse](https://www.babeljs.cn/docs/babel-traverse) 对其进行 **深度优先遍历**，维护AST树的整体状态，并且可完成对其的替换，删除或者增加节点，这个方法的参数为原始AST和自定义的转换规则，返回结果为转换后的AST。

**@生成（`Generator`）**

根据变换后的抽象语法树再生成代码字符串，同时还会创建 [源码映射（`source maps`）](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/)

代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。

Babel通过[@babel/generator](https://www.babeljs.cn/docs/babel-generator) 再转换成js代码，过程就是深度优先遍历整个AST，然后构建可以表示转换后代码的字符串。

# 四、实战 AST 的运用



# 五、初体验

**① 起步**

创建一个基本的项目文件结构，并新建必要文件，如下所示：

```ini
babel-demo
.
├── src
│   └── app.js  
└── package.json
```

> 注意：` package.json` 文件通过 `npm init -y` 指令自动生成。

**② 安装依赖**

```shell
$ npm init -y
$ npm install --save-dev @babel/core @babel/cli @babel/preset-env
```

**③ 配置文件**

在根目录中创建 `babel.config.json` 配置文件，并将以下内容复制到此文件中：

```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": ["last 2 versions", "safari >= 7"]
        },
        "useBuiltIns": "usage",
        "corejs": "3.6.5"
      }
    ]
  ]
}
```

> 上述浏览器列表（`browsers`）仅用于示例。请根据你所需要支持的浏览器进行调整。参见 [此处](https://www.babeljs.cn/docs/babel-preset-env) 以了解 `@babel/preset-env` 可接受哪些参数。

**④ 基本使用**

通过上面的准备工作，我们现在就可以使用 Babel 进行编译转换了。在 `/src/app.js` 文件中写一个es6的箭头函数

```javascript
(function () {
  const hello = (name) => {
    console.log(`Hello, ${name}!`);
  };
  hello('Babel');
})();
```

现在使用Babel命令行工具进行编译

```shell
# -- 编译文件
$ ./node_modules/.bin/babel src/app.js --out-file lib/app.js -w -s
# -- 编译目录
$ ./node_modules/.bin/babel src --out-dir lib -w -s
```

解读：

- `-o`：将某个js文件编译成指定js文件

- `-d`：将某个目录下的js文件编译至指定目录

- `-w`：实时监听文件/自动编译

- `-s`：生成资源映射文件便于调试，它可以帮助你在浏览器开发者工具（目前只有google chrome浏览器支持该功能）的“Source”选项卡中找到编译前的源文件，方便开发者进行调试。

  但首先得确保你开发者工具的设置里的这一项是处于勾选状态：`右键检查` → `工具栏中选择更多(右上角三个竖着的小圆点)` →  `Setting` →  `Sources` →  `Enable JavaScript source maps.`

经过编译后生成的 `lib/app.js` 是这样的：

```javascript
(function () {
  var hello = function hello(name) {
    console.log("Hello, ".concat(name, "!"));
  };

  hello('Babel');
})();
```

**⑤ 简化使用**

在 `package.json`  文件的 `scripts` 属性下，设置如下代码：

```json
"scripts": {
  "dev": "./node_modules/.bin/babel src --out-dir lib -w -s"
},
```

> 提示：`dev` 这个属性名是自定义的，其属性值则是要执行的指令。

内容配置完成之后，切换到命令行窗口输入：

 ```shell
$ npm run dev
 ```

这样即可执行指令进行编译。

# 六、配置文件

可以通过几种不同的方式来使用配置文件：

- `babel.config.json`：v7.8.0以上（建议使用）
- `babel.config.js`：旧版本
- `.babelrc`
- `package.json['babel']`

> **常用Options字段说明**

- `env`：定在不同环境下使用的配置。
- `plugins`：加载和使用的插件列表，插件名前的babel-plugin-可省略；plugin列表按从头到尾的顺序运行。
- `presets`：要加载和使用的preset列表，preset名前的babel-preset-可省略；presets列表的preset按从尾到头的**逆序**运行（为了兼容用户使用习惯）

> **配置文件的查找**

Babel 会从当前转译的文件所在目录下查找配置文件，如果没有找到，就顺着文档目录树一层层往上查找，一直到 `.babelrc` 文件存在或者带 `babel` 字段的 `package.json` 文件存在为止。



# 七、Vue 中AST抽象语法树的运用

vue中AST主要运用在 **模板编译** 过程。我们先来看看 vue 模板编译的整体流程。

Vue2.x：`template(模板)` → `parse(模板基础编译)` → `optimize(优化AST)` → `generate(生成js字符串)` → `Render函数`

Vue3.x：`Template(模板)`  → `Parse(解析)` → `Transform(转换)` → `Generate(生成)` → `Render函数`

vue中的模板编译主要分为三个步骤：

1）解析器阶段：将 template 里面的代码解析成AST抽象语法树;

2）优化器阶段：将AST抽象语法树静态标签打上`tag`，防止重复渲染(优化了 `diff` 算法)；

3）代码生成器阶段：优化后的AST抽象语法树通过 `generate` 函数生成 `render` 函数字符串；

我们来看看vue源码的整体实现过程：

> 源码位置：`vue/dist/vue.global.js` → `rows：14975`

```javascript
function baseCompile(template, options = {}) {
  // -- baseParse：解析生成AST
  const ast = isString(template) ? baseParse(template, options) : template;
  // -- 对AST进行转换
  transform(
    ast,
    extend({}, options, { ··· })
  );
  // -- 生成可执行函数
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers,
    })
  );
}
```

> 提示：这里只是简单列举出了 `vue3 - baseCompile` 方法中的核心代码，如果大家有兴趣，可以自行去阅读源码。

解析器要实现的功能就是将模板解析成 AST，我们这里主要来分析一下代码解析阶段，这里主要运用的是 `baseParse()` 这个函数，事实上，解析器内部也分为好几个解析器，比如 `HTML解析器`**、**`文本解析器` 以及 `过滤解析器`，其中最主要的就是HTML解析器。HTML解析器的作用就是解析HTML，它在解析HTML的过程中会不断触发各种钩子函数，我们来看看代码实现：

> 源码位置：`vue/dist/vue.global.js` → `rows：11713`

```javascript
function parseTag(context, type, parent) {
  // Tag open.
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  // save current state in case we need to re-parse attributes with v-pre
  const cursor = getCursor(context);
  const currentSource = context.source;
  // check <pre> tag
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  // Attributes.
  let props = parseAttributes(context, type);
  // check v-pre
  if (
    type === 0 /* Start */ &&
    !context.inVPre &&
    props.some((p) => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')
  ) {
    context.inVPre = true;
    // reset context
    extend(context, cursor);
    context.source = currentSource;
    // re-parse attrs and filter out v-pre itself
    props = parseAttributes(context, type).filter((p) => p.name !== 'v-pre');
  }
  // Tag close.
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9 /* EOF_IN_TAG */);
  } else {
    isSelfClosing = startsWith(context.source, '/>');
    if (type === 1 /* End */ && isSelfClosing) {
      emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1 /* End */) {
    return;
  }
  let tagType = 0; /* ELEMENT */
  if (!context.inVPre) {
    if (tag === 'slot') {
      tagType = 2 /* SLOT */;
    } else if (tag === 'template') {
      if (
        props.some(
          (p) =>
            p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name)
        )
      ) {
        tagType = 3 /* TEMPLATE */;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1 /* COMPONENT */;
    }
  }
  return {
    type: 1 /* ELEMENT */,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined, // to be created during transform phase
  };
}
```



# 八、插件

插件主要应用在转换阶段

## 1. 基本结构

典型的 Babel 插件结构，如下代码所示：

```javascript
// 这个types就是babel-types，在注册babel插件时解构就有它
module.exports = function ({ types: babelTypes }) {
  return {
    name: 'transfer-plugin',
    visitor: {
      Identifier(path, state) {
        // 插件内容
      },
    },
  };
};
```

需要关注的内容如下：

- `babelType`：`@babel/types` 工具库，主要用来操作AST节点，比如创建、校验、转变等。

- `path`：path 存储着AST节点信息以及一些节点操作方法。

  - 属性：

    - `node`：当前遍历到的node节点
    - `parent`：父级 AST 节点
    - `parentPath`：父级path
    - `scope`：作用域

  - 方法：

    - `get`：获取子节点
    - `findParent`：向父节点搜寻节点
    - `getSibling`： 获取兄弟路径
    - `getFunctionParent`： 获取包含该节点最近的父函数节点(查找的是function)
    - `getStatementParent`： 向上获取最近的statement类型节点
    - `relaceWith`：用AST节点替换该节点
    - `relaceWithMultiple`： 用多个AST节点替换节点
    - `replaceWidthSourceString`： 用源码解析后的AST节点替换节点
    - `insertBefore`：在之前插入兄弟节点
    - `insertAfter`： 在之后插入兄弟节点
    - `remove`：删除节点
    - `pushContainer`： 将AST push到节点属性里面
    - `stop`： 停止遍历
    - `skip`： 跳过此次遍历

    > 提示：更多属性与方法，请 [参考这里 >>](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-babel-generator)

- `state`：状态，你可以通过 `state` 访问插件的配置项。

- `visitor`：Babel 采取递归的方式访问AST的每个节点，之所以叫做 `visitor`，只是因为有个类似的设计模式叫做 [访问者模式](https://en.wikipedia.org/wiki/Visitor_pattern)，不用在意背后的细节。

- `Identifier`：AST的每个节点，都有对应的节点类型，比如标识符（`Identifier`）、函数声明（`FunctionDeclaration`）等，可以在 `visitor` 上声明同名的属性，当Babel遍历到相应类型的节点，属性对应的方法就会被调用，传入的参数就是 `path`、`state`。

## 2. 简单实现

现在，我们开发一个插件，支持文本替换，替换文本通过配置项传入。

首先创建插件文件，编辑如下内容：

```javascript
// -- plugins/transfer-plugin.js
module.exports = function ({ types: babelTypes }) {
  return {
    name: 'transfer-plugin',
    visitor: {
      Identifier(path, state) {
        let name = path.node.name;
        if (state.opts[name]) {
          path.node.name = state.opts[name];
        }
      },
    },
  };
};
```

接下来，我们试试该插件是否能够成功转换，比如我需要将如下代码：

```javascript
(function () {
  const bad = true;
  const dead = true;
})();
```

中的 `bad` 替换成 `good`，然后将 `dead` 替换成 `alive`。

首先我们需要在配置文件中引用改插件并传入配置项，如下所示：

```javascript
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": ["last 2 versions", "safari >= 7"]
        },
        "useBuiltIns": "usage",
        "corejs": "3.6.5"
      }
    ]
  ],
  "plugins": [
    [
      "./plugins/transfer-plugin.js",
      {
        "bad": "good",
        "dead": "alive"
      }
    ]
  ]
}
```

执行编译指令：`npm run dev`，查看编译结果：

```javascript
(function () {
  var good = true;
  var alive = true;
})();
```

可以看到，`bad` 和 `dead` 成功转换成了 `good` 和 `alive`，怎么样，是不是很简单呢？

