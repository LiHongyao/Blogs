> **参考文献**
>
> - [webpack 中文文档 >>](<https://webpack.docschina.org/>)

# 一、概述

![](IMGS/webpack-des.png)

本质上，`webpack` 是一个用于现代 JavaScript 应用程序的 `静态模块打包工具`。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 [依赖图(dependency graph)](https://webpack.docschina.org/concepts/dependency-graph/)，然后将你项目中所需的每一个模块组合成一个或多个 `bundles`，它们均为静态资源，用于展示你的内容。

从图中我们可以看出，webpack 可以将多种静态资源 js、css、sass 转换成一个静态文件，减少了页面的请求。

## 1. 什么是webpack？

> webpack 可以看做是 **模块打包机**：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。

这段话有三个重点：

- `打包`：可以把多个 JavaScript 文件打包成一个文件，减少服务器压力和下载带宽。
- `转换`：把拓展语言转换成为普通的 JavaScript，让浏览器顺利运行。
- `优化`：前端变的越来越复杂后，性能也会遇到问题，而 webpack 也开始肩负起了优化和提升性能的责任。

## 2. 为什么需要webpack？

webpack 是现代前端技术的基石，常规的开发方式，比如  jQuery、HTML、CSS 静态网页开发已经落后了。现在是 MVVM 的时代，数据驱动视图，webpack  将现代js开发中的各种新型有用的技术，集合打包。通过下图理解webpack生态圈：

![](./IMGS/webpack-ecosphere.jpg)


## 3. 模块化

模块化是一种将复杂系统分解为更好的可管理模块的方式，简单来说就是解耦。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。

其优势为：简化开发、按需加载、便于管理、可复用。

目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。webpack是一个模块打包机，它对模块有一个更广泛的定义，对于webpack来说，模块是：

- Common JS modules
- AMD modules
- ES modules
- CSS import
- Images url

webpack 还可以从这些模块中获取 **依赖关系**。

更多内容，可参考 [这里 >>](https://juejin.cn/post/7046265436408643615)

# 二、初探 

## 1. 准备

```shell
$ mkdir webpack-demo & cd webpack-demo & npm init -y 
$ npm install webpack webpack-cli webpack-dev-server --save-dev
$ ./node_modules/.bin/webpack --version    
webpack: 5.65.0
webpack-cli: 4.9.1
webpack-dev-server 4.7.1
```

> 提示：windows 系统提示 “'.' 不是内部或外部命令，也不是可运行的程序或批处理文件。”，需将上述指令中路径部分中的 `/` 变为 `\` 即可。

## 2. 创建项目结构

接下来创建如下项目结构：

```
.
├── dist
    └── index.html
├── node_modules
├── package.json
└── src
    ├── app.js
   	└── utils
   	    └── index.js
```

>  提示：
>
>  1. `src` 是源码文件，`dist` 是我们编译打包好的文件；
>  2. `node_modules` 为 `yarn` 或 `npm` 安装依赖时自动生成的文件。

## 3. 编辑项目文件

> `dist/index.html`

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>webpack - test</title>
  </head>
  <body>
    <h1 id="title"></h1>
    <!-- 引入webpack打包后生成的文件 -->
    <script src="./js/main-bundle.js"></script>
  </body>
</html>
```
> `src/utils/index.js`

```javascript
/**
 * 修改元素标题
 * @param {*} id
 * @param {*} title
 */
export function setTitle(id, title) {
  const dom = document.getElementById(id);
  dom.textContent = title;
}
```
> src/app.js

```javascript
import * as Utils from './utils';

Utils.setTitle('title', 'Hello, webpack!');
```

## 4. 创建配置文件 

在 <ins>项目根目录下</ins> 创建 “webpack.config.js ” 文件，配置如下：

```javascript
// 1. 引入模块
const path = require('path');

// 2. 导出配置
module.exports = {
  // 配置基础路径为当前目录（默认为配置文件所在的当前目录）
  context: path.resolve(__dirname, './'),
  // 打包模式 development / production
  mode: 'development',
  // 入口
  entry: {
    main: './src/app.js',
  },
  // 出口
  output: {
    // 输出目录/绝对路径
    path: path.resolve(__dirname, './dist/'),
    // 输出文件名
    filename: 'js/[name]-bundle.js',
  },
  // 加载器
  module: {
    rules: [],
  },
  // 开发服务
  devServer: {},
};
```

## 5. 编译打包 - npm scripts

你可以通过在终端输入如下指令执行打包操作：

```shell
$ ./node_modules/.bin/webpack
```

考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 `package.json` 文件，添加一个 [npm script](https://docs.npmjs.com/misc/scripts)：

```json
"scripts": {
  "start": "webpack"
}
```

> 提示：你可能会发现，配置 npm script 时，为什么不是 `./node_modules/.bin/webpack` 的指令而直接是 `webpack`，这是因为 `node` 会自动去识别`node_modules`下的 `bin` 目录执行。

接下来，我们执行如下操作进行打包：

```shell
$ npm run start

> hello-webpack@1.0.0 start E:\远程仓库\Blogs\CODES\hello-webpack
> webpack

asset js/main-bundle.js 4.57 KiB [emitted] (name: main)
runtime modules 670 bytes 3 modules
cacheable modules 512 bytes
  ./src/app.js 206 bytes [built] [code generated]
  ./src/utils/index.js 306 bytes [built] [code generated]
webpack 5.65.0 compiled successfully in 210 ms
```

执行打包任务之后，会在 `./dist/js` 目录下生成一个  `main-bundle.js` 文件，运行 `index.html` 可以看到 `Hello, webpack!` 说明打包成功。

> 提示：你可以尝试不同的打包模式观察二者的区别。

## 6. dev Server

[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 为你提供了一个简单的 Web Server，并且具有 live reloading（实时重新加载） 功能。

devServer 配置如下：

```javascript
devServer: {
  static: {
    directory: path.join(__dirname, 'dist'),
  },
  compress: true,
},
```

> 提示：更多配置可参考 [这里](https://webpack.docschina.org/configuration/dev-server) 。

添加 npm script：

```javascript
"scripts": {
  "start": "webpack",
  "serve": "webpack serve --open --host=local-ip --port=8090 --hot=only"
},
```

执行 serve 脚本（`npm run serve`），我们就会看到浏览器自动加载页面，如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载。

> 注意：
>
> 1. webpack-dev-server 在编译之后不会输出任何文件。而是将 bundle 文件保留在内存中，然后将它们 serve 到 server 中，就好像它们是挂载在 server 根路径上的真实文件一样。如果你的页面希望在其他不同路径中找到 bundle 文件，则可以通过 dev server 配置中的 [`publicPath`](https://webpack.docschina.org/configuration/dev-server/#devserver-publicpath-) 选项进行修改。
>
> 2. 如果你自定义了配置文件，如 “webpack.dev.config.js”，那么在执行devServer的时候，也要指定相应的配置文件，如：
>
>    ```shell
>    $ webpack serve --config webpack.dev.config.js
>    ```
>
> 3. 在开发阶段，我们可以通过设置  `output ` 中的 `publicPath` 字段访问静态资源，以刚刚配置 devServer 为例，我们可以在 `output` 出口设置中添加如下字段：`publicPath: "http://192.168.101.31:8888/"`，此时，你静态资源的访问路径将会变成：`publicPath + 静态资源地址`，待项目上线之后，再将 publicPath 设置为线上地址即可。
>
> 4. 指令中的 `--hot` 便是启用 [模块热替换](https://webpack.docschina.org/guides/hot-module-replacement/)，我们需要引入webpack内置组件，并添加在 plugins字段中：
>
>    ```js
>    plugins: [new webpack.HotModuleReplacementPlugin()]
>    ```

## 7. 扩展知识

### 7.1. * 指定配置文件编译

在实际开发过程中，你可能会创建不同的 `config.js` 文件来满足不同的开发需求，比如你在开发阶段，通常会创建一个 `webpack.dev.config.js` 文件，那么你在执行编译指令的时候需要指向该配置文件，如下所示：

```shell
$ ./node_modules/.bin/webpack --config ./build/webpack.dev.config.js
```

> 提示：假设配置文件的路径是：`./build/webpack.dev.config.js`，那你需要在配置文件中做如下修改：
>
> ```js
> module.exports = {
>     context: path.resolve(__dirname, "../"),
>     output: {   
>         path: path.resolve(__dirname, "../dist/"),
>     }
> };
> ```

### 7.2. * 编译参数配置

webpack 自身提供了一些参数来优化编译任务，以下简单列出了一些参数：

| 参数          | 描述               |
| ------------- | ------------------ |
| `--config`    | 指定配置文件       |
| --watch, `-w` | 监听变动并自动打包 |
| `-p`          | 压缩混淆脚本       |
| `--progress`  | 显示进度条         |

> 提示：想了解webpack更多参数，可在终端输入 `./node_modules/.bin/webpack -h`  查看

## 8. 构建过程

- 初始化：启动构建，读取与合并配置参数，加载 [Plugin](https://www.webpackjs.com/api/plugins/)，实例化 [Compiler](https://www.webpackjs.com/api/compiler-hooks/)。

- 编译：从 [Entry](https://webpack.docschina.org/concepts/#入口-entry-) 发出，针对每个 [Module](https://webpack.docschina.org/concepts/modules/#src/components/Sidebar/Sidebar.jsx) 串行调用对应的 [Loader](https://webpack.docschina.org/concepts/loaders/#src/components/Sidebar/Sidebar.jsx) 去翻译文件内容，再找到该 [Module](https://webpack.docschina.org/concepts/modules/#src/components/Sidebar/Sidebar.jsx) 依赖的 [Module](https://webpack.docschina.org/concepts/modules/#src/components/Sidebar/Sidebar.jsx)，递归地进行编译处理。

- 输出：对编译后的 Module 组合成 [Chunk](https://zhuanlan.zhihu.com/p/21318102)，把 [Chunk](https://zhuanlan.zhihu.com/p/21318102) 转换成文件，输出到本地。

# 三、核心

## 1. Entry

`Entry`：入口起点，指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

入口文件常用的配置形式如下：

```js
module.exports = {
    entry: {
        "main": "./src/js/main.js",
        "news": "./src/js/news.js"  
    }
}
```

> 提示：在多页面项目中设置出口时，通过`[name]` 即可获取文件名，其中文件名就是入口设置中的 `key` 项。

## 2. Output

`Output`：该属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。

出口文件常用的配置形式如下：

```javascript
output: {
  // 输出目录/绝对路径
  path: path.resolve(__dirname, "./dist/"),
  // 输出文件名
  filename: "js/[name]-bundle.js",
  // 处理静态资源路径
  // 静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径
  // 这里假设开启devServer服务
  publicPath: "http://localhost:8080/",
}
```

- `[name]`：模块名称，也就是在指定入口时的 `key` 值。
- `[hash]`：打包后文件的 hash 值，md5，保证文件唯一性。
- `[chunkhash]`：模块自身的hash值。

## 3. Loader

webpack 只能理解 JavaScript 和 JSON 文件。**loader** 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 [模块](https://webpack.docschina.org/concepts/modules)，以供应用程序使用，以及被添加到依赖图中。

```js
module.exports = {
    module: {
        rules: []
    }
}
```

- `test`：required - 处理文件
- `use`：required - 加载器
- `include/exclude`：optional - 包含/不包含文件；

## 4. Plugins

插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。
Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的，一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程起作用。

Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。

使用插件步骤：

- 安装插件
- 导入插件
- 在 plugins 数组中创建插件实例

# 四、实战

## 1. 准备工作

**① 创建项目 - 安装依赖**

```shell
$ mkdir webpack-demo & cd webpack-demo & npm init -y 
$ npm install webpack webpack-cli webpack-dev-server clean-webpack-plugin webpack-bundle-analyzer --save-dev
$ ./node_modules/.bin/webpack --version    
webpack: 5.65.0
webpack-cli: 4.9.1
webpack-dev-server 4.7.1
```

> 提示：windows 系统提示 “'.' 不是内部或外部命令，也不是可运行的程序或批处理文件。”，需将上述指令中路径部分中的 `/` 变为 `\` 即可。

> 依赖解读：

- [webpack-dev-server]()：开发服务
- [clean-webpack-plugin]()：文件清除
- [ webpack-bundle-analyzer]()：依赖分析

**② 目录结构**

```ini
webpack-test
.
├── node_modules
├── src
│   ├── styles
│   │   └── index.less
│   ├── app.js
│   └── index.html
├── package.json
└── webpack.config.js
```

**③ 文件内容**

> **npm script**

```javascript
"scripts": {
  "build": "webpack --mode=production",
  "serve": "webpack serve --open --hot --host=local-ip --port=8090 --mode=development"
},
```

> **webpack.config.js**

```js
// 1. 引入模块
const path = require('path');
const webpack = require('webpack');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

// 2. 导出配置
module.exports = {
  context: path.resolve(__dirname, './'),
  entry: {
    main: './src/app.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name]-bundle-[hash].js',
  },
  plugins: [
    new CleanWebpackPlugin(),
    new webpack.BannerPlugin('版权Li-HONGYAO所有，翻版必究！'),
  ],
  devServer: {
    liveReload: true,
    watchFiles: ['src/**'],
    static: {
      directory: path.join(__dirname, 'dist'),
    },
  },
};
```

> **src/utils/index.js**

```javascript
/**
 * 修改元素标题
 * @param {*} id
 * @param {*} title
 */
export function setTitle(id, title) {
  const dom = document.getElementById(id);
  dom.textContent = title;
}
```

> **src/app.js**

```javascript
import * as Utils from './utils/index.js';

Utils.setTitle("title", "Hello, webpack!!!");
```

> **src/styles/index.less**

```css
#title {
  color: blue;
  letter-spacing: 2px;
  font-size: 36px;
}
```

> **src/index.html**

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>webpack - test</title>
  </head>
  <body>
    <h1 id="title"></h1>
  </body>
</html>
```

## 2. 打包HTML

安装依赖：

```shell
$ npm install html-webpack-plugin --save-dev
```

配置文件：

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      // -- 模板文件
      template: 'src/index.html',
      // -- 文件名，相对于output.path，
      // -- 可通过文件名设置目录，如 static/pages/detail.htm
      filename: 'index.html',
      // -- 指定输出文件所依赖的入口文件（*.js）的[name]
      chunks: ['main'],
    }),
  ]
};
```

## 3. 打包脚本

安装依赖：

```shell
$ npm install babel-loader @babel/core @babel/preset-env --save-dev
```

配置文件（`module.rules`）：

```json
{
  test: /\.js$/,
  exclude: /node_modules/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env', { targets: 'defaults' }],
    },
  },
},
```

## 4. 打包样式

安装依赖：

```shell
$ npm install style-loader css-loader less less-loader postcss-loader postcss-preset-env --save-dev
```

依赖解读：

- [style-loader](https://www.npmjs.com/package/style-loader)：将所有计算后的样式加入页面中；
- [css-loader](https://www.npmjs.com/package/css-loader)：使你能够使用类似 `import` 和 `url()`  的方法实现  `require()` 的功能；
- [less-loader](https://www.npmjs.com/package/less-loader)：编译LESS，如果需要编译SASS，可以使用 [sass-loader](https://www.npmjs.com/package/sass-loader)；
- [postcss-loader](https://www.npmjs.com/package/postcss-loader)：CSS代码转换工具；
- [postcss-preset-env](https://www.npmjs.com/package/postcss-preset-env)：预设

配置文件：

```json
{
  test: /\.less$/,
  exclude: /node_modules/,
  use: [
    'style-loader',
    'css-loader',
    {
      loader: 'postcss-loader',
      options: {
        postcssOptions: {
          plugins: ['postcss-preset-env'],
        },
      },
    },
    'less-loader',
  ],
},
```

> 注意：引用顺序为从右到左。

**→ 分离样式**

如果需要分离CSS文件，可使用插件 [mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin)，webpack v4.0之前使用 [extract-text-webpack-plugin](https://www.npmjs.com/package/extract-text-webpack-plugin) 。

首先安装依赖：

```shell
$ npm install --save-dev mini-css-extract-plugin
```

然后修改配置文件：

```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name]-[hash].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.less$/,
        exclude: /node_modules/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          {
            loader: 'postcss-loader',
            options: {
              postcssOptions: {
                plugins: ['postcss-preset-env'],
              },
            },
          },
          'less-loader',
        ],
      },
    ],
  },
};
```

> 提示：如果使用 `MiniCssExtractPlugin`，就不需要引入 `style-loader` 了。

**→ 去除无效样式**

安装依赖：

```shell
$ npm install  purgecss-webpack-plugin --save-dev
```

配置代码：

```javascript
const glob = require('glob');
const PurgeCSSPlugin = require('purgecss-webpack-plugin');

module.exports = {
    plugins: [
        new PurgeCSSPlugin({
        	paths: glob.sync('./src/**/*', { nodir: true }),
        }),
    ]
}
```



## 5. 打包图片

webpack5 新增了[资源模块 >>](https://webpack.docschina.org/guides/asset-modules/)（`asset module`），它允许使用资源文件（字体，图标等）而无需配置额外 loader。在 webpack5之前，通常使用 [url-loader](https://v4.webpack.js.org/loaders/url-loader/) 或 [file-loader](https://v4.webpack.js.org/loaders/file-loader/) 处理图片、字体等静态资源。

安装依赖：

```shell
$ npm install html-loader --save-dev
```

> 提示：安装 `html-loader` 的目的是为了能够在 html 文件中通过 `src` 属性引入的图片资源，需将 `esModule: false`。

配置文件：

```javascript
module.exports = {
  module: {
    rules: [
      // -- 打包图片
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        exclude: /node_modules/,
        type: 'asset/resource',
        generator: {
			filename: 'images/[hash][ext][query]',
        },
      },
      // - 处理html文件中的img图片（负责引入img）
      {
        test: /\.html$/,
        exclude: /node_modules/,
        loader: 'html-loader',
        options: {
          esModule: false,
        },
      },
    ],
  },
};

```

## 6. 打包字体

同样的，打包字体我们直接使用 webpack5中的 [Asset Modules >>](https://webpack.docschina.org/guides/asset-modules/)，无需安装 `loader`，直接配置即可：

```javascript
// -- 打包字体
{
  test: /\.(woff|woff2|eot|ttf|otf)$/i,
  exclude: /node_modules/,
  type: 'asset/resource',
  generator: {
    filename: 'fonts/[hash][ext][query]',
  },
},
```

## 7. 拷贝资源

开发中，有时我们需要将一些资源在打包时直接拷贝至根目录，比如微信公众号配置业务域名时，需将校验文件放置在域名根目录，我们可以将其放置在 `public` 目录下，然后通过 [copy-webpack-plugin >>](https://webpack.docschina.org/plugins/copy-webpack-plugin) 将其拷贝至输出根目录下。

安装依赖：

```shell
$ npm install copy-webpack-plugin --save-dev
```

配置文件：

```javascript
const CopyPlugin = require('copy-webpack-plugin');

module.exports = {
    plugins: [
        new new CopyPlugin({
            patterns: [{ from: 'public' }]
        })      
    ]
}
```

# 四、延伸

## 1. context

上下文，基础目录，**绝对路径**，用于从配置中解析入口起点和 loader，入口起点会相对于此目录查找。默认为当前目录，即配置文件所在的目录，所以一般当自定义配置文件之后，我们需要设置该属性，比如配置文件放在在 ”./build“ 目录中，则上下文配置如下：

```js
context: path.resolve(__dirname, "../");
```

## 2. 资源映射

```javascript
module.exports = {
	devtool: 'eval-source-map'
}
```

总结：调试在开发中也是必不可少的，但是一定要记得在上线前一定要修改webpack配置，在打出上线包。

## 3. 引用三方库

### 3.1. 局部引入

```js
import $ from 'jquery';
```

### 3.2. 全局引入

```js
new webpack.ProvidePlugin({
	$:"jquery", // npm
  jQuery: "jQuery"
})
```

## 4. watch的正确使用方法

在初级开发阶段，使用webpack-dev-server就可以充当服务器和完成打包任务，但是随着你项目的进一步完成，可能需要前后台联调或者两个前端合并代码时，就需要一个公共的服务器了。这时候我们每次保存后手动打包显然效率太低，我们希望的场景是代码发生变化后，只要保存，webpack自动为我们进行打包。这个工具就是watch，这节课我们把wacht完全学会，你会发现在开发中更加的得心应手。

**\> watch的配置**

很多小伙伴认为–watch直接使用就可以，并没有什么需要讲的。其实这只是初级的用法，但是在学习一种技术时，我们必须要做到了解全部，也就是常说的知其然知其所以然。我们看下面的配置代码，我在代码中已经做出了解释。

```javascript
watchOptions:{
    // 检测修改的时间，以毫秒为单位
    poll:1000, 
    // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作
    aggregateTimeout:500, 
    // 不监听的目录
    ignored:/node_modules/, 
}
```

上边的每一行配置我都作了说明，有时候你在没配置的情况下，直接用webpack –watch是不起作用的，这时候你需要进行配置这些选项。

配置好后，我们就可以痛快的使用watch了，在大型项目中，这大大加快了我们的开发效率，不用反复的手动打包了。

## 5. 解析

有时候我们不想路径暴露出去，可以使用取别名的形式：

```javascript
moudle.exports = {
  resolve: {
        // 创建别名
        alias: {
            "main-less": path.resolve(__dirname, './src/less/main.less'),
            "font-icon": "font-awesome/css/font-awesome.css"
        }
    }
}
```

这样在需要引入对应插件的时候，直接使用即可：

```js
require("normalize-css");
require("font-icon");
```

## 6. 抽离公共文件

当一部分代码需要反复被用到，反复请求浪费资源，将公共代码 抽离，需要时读取缓存即可

```js
output: {
  ...
  chunkFilename: "[name].chunk.js"
}
optimization: {
    splitChunks: {
        cacheGroups: {// 缓存组，缓存公共代码
            // 首先：打包node_modules中的文件
            vendor: {
                test: /node_modules/,
                name: "vendor",
                minSize: 0, 
                minChunks: 1,
                chunks: "all",
                priority: 1 
            },
            // 其次: 打包业务中公共代码
            common: {
                name: "common",
                chunks: "all",  
                minSize: 0,      
                minChunks: 2,   
                priority:0
            }
        }
    }
}
```

# 五、注意

- 一旦修改了webpack的配置文件，必须重启服务或重新build。否则失效。
- 如果自定义配置文件，切记在执行打包时一定要指定配置文件路径

# 六、配置代码

```js
// 1. 引入模块
const path = require('path');
const webpack = require('webpack');
// -> 处理Html
const HtmlWebpackPlugin = require('html-webpack-plugin');
// -> 抽离css文件
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
// -> 消除未使用的css
const glob = require('glob');
const PurifyCSSPlugin = require('purifycss-webpack');
// -> 压缩css
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');

// 2. 导出配置
module.exports = {
    // 配置基础路径为当前目录（默认为配置文件所在的当前目录）
    context: path.resolve(__dirname, './'),
    // 打包模式 development - 未压缩 | production - 压缩
    mode: 'development',
    // 入口 string | array | object
    entry: {
        main: './src/js/index.js',
        loginRegister: './src/js/login-register.js'
    },
    // 出口
    output: {
        // 输出目录/绝对路径
        path: path.resolve(__dirname, './dist/'),
        // 输出文件名
        filename: 'static/js/[name]-bundle.js',
        // 处理静态资源的路径
        publicPath: 'http://127.0.0.1:8081/'
    },
    // 加载器
    module: {
        rules: [
            // 编译es语法
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ["@babel/preset-env"]
                    }
                }
            },
            // 编译less
            {
                test: /\.less$/,
                exclude: /node_modules/,
                use: [
                    // "style-loader",
                    // => 使用插件中的loader代替style方式
                    {
                        loader: MiniCssExtractPlugin.loader,
                        options: {
                            reloadAll: true
                        }
                    },
                    "css-loader",
                    {
                        loader: "postcss-loader",
                        options: {
                            ident: "postcss",
                            plugins: [require("autoprefixer")]
                        }
                    },
                    "less-loader"]
            },
            {
                test: /\.css$/,
                // exclude: /node_modules/,
                use: [
                    // "style-loader",
                    // => 使用插件中的loader代替style方式
                    {
                        loader: MiniCssExtractPlugin.loader,
                        options: {
                            reloadAll: true
                        }
                    },
                    "css-loader",
                    {
                        loader: "postcss-loader",
                        options: {
                            ident: "postcss",
                            plugins: [require("autoprefixer")]
                        }
                    }
                ]
            },
            // 处理HTML
            {
                test: /\.html$/,
                use: "html-loader"
            },
            // 处理图片
            {
                test: /\.(jpg|jpeg|png|svg|gif)$/,
                exclude: /node_modules/,
                use: {
                    loader: "url-loader",
                    options: {
                        // <= 2kb，则转换成base64
                        limit: 10000,
                        // 图片名字
                        name: "[name]-[hash:5].[ext]",
                        // 输出路径
                        outputPath: "static/images/",
                        // 启用commonJS规范  
                        esModule: false
                    }
                }
            },
            // 处理字体
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/,
                use: [{
                    loader: 'url-loader',
                    options: {
                        name: '[name]-[hash:5].[ext]',
                        limit: 5000,
                        outputPath: 'static/fonts/'
                    }
                }]
            }
        ]
    },
    // 插件
    plugins: [
        // -> 版权声明
        new webpack.BannerPlugin("版权耀哥所有，翻版必究！"),
        // -> 热替换
        new webpack.HotModuleReplacementPlugin(),
        // -> 引入三方库
        new webpack.ProvidePlugin({
            $: "jquery", // npm
            jQuery: "jQuery"
        }),
        // -> 抽离CSS文件
        new MiniCssExtractPlugin({ filename: "static/css/[name].css" }),
        // -> 消除未使用的css
        new PurifyCSSPlugin({
            // Give paths to parse for rules. These should be absolute!
            paths: glob.sync(path.join(__dirname, "./src/**/*.html")),
        }),
        // -> 压缩css
        new OptimizeCSSAssetsPlugin({
            // 默认是全部的CSS都压缩，该字段可以指定某些要处理的文件
            assetNameRegExp: /\.(sa|sc|c|le)ss$/g,
            // 指定一个优化css的处理器，默认cssnano
            cssProcessor: require('cssnano'),
            cssProcessorPluginOptions: {
                preset: ['default', {
                    discardComments: { removeAll: true }, // 对注释的处理
                    normalizeUnicode: false // 建议false,否则在使用unicode-range的时候会产生乱码
                }]
            },
            canPrint: true  // 是否打印编译过程中的日志
        }),
        // —> 处理html
        new HtmlWebpackPlugin({
            // 模板文件
            template: "./src/index.html",
            // 文件名(相对于output.path)，可通过文件名设置目录，如 static/pages/detail.html
            filename: "index.html",
            // 静态资源位置
            inject: "body",
            // 指定输出文件所依赖的入口文件（*.js）的[name]
            chunks: ["main"],
            // 控制压缩
            minify: {
                collapseWhitespace: false,
                removeComments: true,
                removeAttributeQuotes: true,
                removeEmptyAttributes: true
            }
        }),
        new HtmlWebpackPlugin({
            // 模板文件
            template: "./src/pages/login-register.html",
            // 文件名(相对于output.path)，可通过文件名设置目录，如 static/pages/detail.html
            filename: "static/pages/login-register.html",
            // 静态资源位置
            inject: "body",
            // 指定输出文件所依赖的入口文件（*.js）的[name]
            chunks: ["loginRegister"],
            // 控制压缩
            minify: {
                collapseWhitespace: false,
                removeComments: true,
                removeAttributeQuotes: true,
                removeEmptyAttributes: true
            }
        }),
    ],
    // 开发服务
    devServer: {
        contentBase: path.resolve(__dirname, "./dist/"),
        host: "127.0.0.1",
        port: 8081,
        open: true,
        inline: true,
        hot: true // 热替换
    }
};


```























