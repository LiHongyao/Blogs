> 参考

1. https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw
2. https://github.com/creeperyang/blog/issues/33

# 前言

伴随 React 兴起， Virtual DOM 也越来越火，各种各样的实现，各个 UI 库的引入等等。

**什么是 Virtual DOM ？**

在谈论 Virtual DOM 之前，必须要理解：什么是 DOM ？

DOM 即 Document Object Model，是一种 **通过对象表示结构化文档的方式** 。DOM 是跨平台的，也是语言无关的（比如 HTML 和 XML 都可以用它表示与操作）。浏览器处理 DOM 的实现细节，然后我们可以通过 JavaScript 和 CSS 来与它交互。

DOM 的主要问题是没有为创建动态 UI 而优化。

以前直接使用 DOM API 比较繁琐，然后有了 jQuery 等库来简化 DOM 操作；但这没有解决大量 DOM 操作的性能问题。大型页面／单页应用里动态创建／销毁 DOM 很频繁（尤其现在前端渲染的普遍），我们当然可以用各种 trick 来优化性能，但这太痛苦了。

而 Virtual DOM 就是解决问题的一种探索。

**Virtual DOM 建立在 DOM 之上，是基于 DOM 的一层抽象，实际可理解为用更轻量的纯 JavaScript 对象（树）描述 DOM（树）**

所以，虚拟`DOM`就是用`js`对象来描述真实`DOM`，它相对于原生`DOM`更加轻量，因为真正的`DOM`对象附带有非常多的属性，另外配合虚拟`DOM`的`diff`算法，能以最少的操作来更新`DOM`，除此之外，也能让`Vue`和`React`之类的框架支持除浏览器之外的其他平台。

操作 JavaScript 对象当然比操作 DOM 快，因为不用更新屏幕。我们可以随意改变 Virtual DOM ，然后找出改变再更新到 DOM 上。但要保证高效，需要解决以下问题：

1. 高效的 diff 算法，即两个 Virtual DOM 的比较；
2. 只更新需要更新的 DOM 节点；
3. 数据变化检测，batch DOM 读写操作等等。

本文会参考知名的**snabbdom**库来手写一个简易版的，配合图片示例一步步完成代码，一定让你彻底理解虚拟`DOM`的`patch`及`diff`算法。

# 创建虚拟DOM对象

虚拟`DOM`（下文称`VNode`）就是使用`js`的普通对象来描述`DOM`的类型、属性、子元素等信息，一般通过名为`h`的函数来创建，为了纯粹的理解`VNode`的`patch`过程，我们先不考虑元素的属性、样式、事件等，只考虑节点类型及节点内容，看一下此时的`VNode`结构：

```json
{
    tag: '',// 元素标签
    children: [],// 子元素
    text: '',// 子元素是文本节点的话，保存文本
    el: null// 对应的真实dom
}
```

`h`函数根据接收的参数返回该对象即可：

```js
export const h = (tag, children) => {
  let text = "";
  let el;
  // 子元素是文本节点
  if (typeof children === "string" || typeof children === "number") {
    text = children;
    children = undefined;
  } else if (!Array.isArray(children)) {
    children = undefined;
  }
  return {
    tag, // 元素标签
    children, // 子元素
    text, // 文本子节点的文本
    el, // 真实dom
  };
};
```

比如我们要创建一个`div`的`VNode`可以这样使用：

```js
h('div', '我是文本')
h('div', [h('span')])
```

# 详解patch过程

`patch`函数是我们的主函数，主要用来进行新旧`VNode`的对比，找到差异来更新实际`DOM`，它接收两个参数，第一个参数可以是`DOM`元素或者是`VNode`，表示旧的`VNode`，第二参数表示新的`VNode`，一般只有第一次调用时才会传`DOM`元素，如果第一个参数为`DOM`元素的话我们直接忽略它的子元素把它转为一个`VNode`：

```js
export const patch = (oldVNode, newVNode) => {
  // dom元素
  if (!oldVNode.tag) {
    let el = oldVNode;
    el.innerHTML = "";
    oldVNode = h(oldVNode.tagName.toLowerCase());
    oldVNode.el = el;
  }
};
```

接下来新旧两个`VNode`就可以进行比较了：

```js
export const patch = (oldNode, newNode) => {
  // ...
  patchVNode(oldVNode, newVNode);
  // 返回新的vnode
  return newVNode;
};
```

在`patchVNode`方法里我们对新旧`VNode`进行比较及更新`DOM`。

首先如果两个`VNode`的类型不同，那么不用比较，直接使用新的`VNode`替换旧的：











